<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
	</head>
	<body>
		<template>
			<div class="next-subtitled"></div>
			<h1 id="a-brief-history-of-emilia">A Brief History of Emilia</h1>
			<p>Dec. 25, 2018</p>
			<p>
				Over the course of eight years and many builds, I have come to see a
				fledgeling desire to steal my father's computer passwords transform into
				7000 lines of C++, a sub-par webserver for HTTP and SMTP, and a wealth
				of experience about low-level WinAPI and network protocols that I'll
				probably never use again.
			</p>
			<p>
				Join me on a brief tour of the history of <code>Emilia</code>, from
				conception to discovery to implementation!
			</p>
			<p>
				This also includes a tour of the evolution of the Rain library, an
				abstraction layer I've built over the years as necessary.
			</p>
			<p>
				<video src="emilia.md-assets/emilia.webm" autoplay loop muted></video
				><br />
				<em>A smiling Emilia (not the webserver).</em>
			</p>
			<h2 id="early-years-with-c">Early Years with C++</h2>
			<p>
				C++ became my favorite language when I came to learn that it was capable
				to writing every application on a computer I had ever used. Unlike the
				higher-level languages, which would need to integrate other frameworks
				to build a complete application, C++ did not need any libraries beyond
				those provided by Windows to build everything I had used. My early
				passions for coding stemmed, like many, from a desire to create games
				like those which had give me so much joy.
			</p>
			<h3 id="infection-a-simple-console-game">
				Infection: A Simple Console Game
			</h3>
			<p>
				One of my more complete games, written in 2011, is called
				<code>Infection</code>.
			</p>
			<p>
				You run a lemonade stand and sell infected food to customers until you
				kill the entire population. Lemonade consists of three components:
				lemons, water and ice. The more of those three are infected, the more
				likely the customers will get infected. There's a bunch of mechanics
				regarding how the disease spreads and wanes, as well as how much the
				public trusts the food from your stand.
			</p>
			<p>
				It's like taking the worst parts of running an <em>actual</em> lemon
				stand and the Pandemic game and putting them together. Here's a short
				GIF of the game.
			</p>
			<p>
				<video src="emilia.md-assets/infection.webm" autoplay loop muted></video
				><br />
				<em
					>Me losing $11 selling very expensive, non-infected, lemonade. Not
					really worth it.</em
				>
			</p>
			<p>
				Infection used multithreading to constantly evaluate the world-state and
				either print it or present menu options for selling lemonade.
				Multithreading and blocking on <code>cin</code> with
				<code>getch</code> for menu selection was non-trivial to implement.
				Perhaps most annoying was the time spent printing to <code>cout</code>,
				which would cause the console to flicker for a short second (visible in
				the GIF above) while the new world-state was displayed.
			</p>
			<p>
				There's two ways of solving the flickering problem. One: use
				<code>system(clear)</code>. However, as many on the web would tell you,
				this isn't very safe. The other option is to switch to a GUI. I heavily
				favored this option. After all, many of the games I played were
				graphical, and I wished to emulate them.
			</p>
			<h3 id="windows-api--gui">Windows API &amp; GUI</h3>
			<p>
				The first complete WinAPI GUI application I coded was called
				<code>TurboWord</code>. <code>TurboWord</code> was a flashcard
				application, which would organize vocabulary into sets and decks of
				flashcards, which could be edited and viewed and reviewed.
			</p>
			<p>
				<video src="emilia.md-assets/turboword.webm" autoplay loop muted></video
				><br />
				<em
					>Example use of <code>TurboWord</code> with a pre-established library
					of flashcards.</em
				>
			</p>
			<p>
				Looks simple, right? Well, it turns out that WinAPI doesn't give you
				much to work with. A lot of the behavior you may think obvious I had to
				implement myself.
			</p>
			<ul>
				<li>
					Create custom window, then draw the custom frame with the icon, title,
					and buttons.
					<ul>
						<li>Custom-made program icon the top-left.</li>
					</ul>
				</li>
				<li>
					Define <code>MOUSEMOVE</code>, <code>LBUTTONDOWN</code>,
					<code>LBUTTONUP</code>, and mouse capture for basically all buttons.
					<ul>
						<li>
							Define internal state transitions and decide when to redraw the
							button.
							<ul>
								<li>
									All redraws must be done on a virtual in-memory canvas then
									transferred with <code>BitBlt</code> to avoid flicker.
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>Define scroll handlers for the select menu.</li>
				<li>
					<code>TextEdit</code> defers to a Windows default
					<code>TextEdit</code> once clicked.
					<ul>
						<li><code>FileEdit</code> does the same.</li>
					</ul>
				</li>
				<li>Calculate position and redraw elements on resize.</li>
			</ul>
			<p>
				It was a big task to complete <code>TurboWord</code>. My next GUI
				project, <code>Coder</code>, was never finished. <code>Coder</code> was
				an application to encode and decode with compression and encryption
				algorithms.
			</p>
			<p>
				<video src="emilia.md-assets/coder.webm" autoplay loop muted></video
				><br />
				<em>Example use of <code>Coder</code>.</em>
			</p>
			<p>
				A you can imagine, all the components in <code>Coder</code> also had to
				be custom styled. To give an idea of what that means, here's the inside
				of the redraw function for the rectangle buttons from
				<code>TurboWord</code>. This redraw reads the state of the button and
				redraws it accordingly. It is called on any state change, which happens
				on mouse events. Most of the work of the code is in setting up all the
				drawing objects and registering with the WinAPI, and so very little is
				the actual drawing logic.
			</p>
			<pre><code class="language-c++"><div>HPEN pen = CreatePen (PS_SOLID, <span class="hljs-number">1</span>, RGB (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)), orig_pen;
HDC DCMem, DC = GetDC (<span class="hljs-keyword">this</span>-&gt;button_wnd);
HBRUSH brush, orig_brush;
HBITMAP BMMem, BMOld;
HFONT font, orig_font;
SIZE tsize;
RECT cRect;

<span class="hljs-comment">//Set up an off-screen DC.</span>
GetClientRect (<span class="hljs-keyword">this</span>-&gt;button_wnd, &amp;cRect);

DCMem = CreateCompatibleDC (DC);
BMMem = CreateCompatibleBitmap (DC, cRect.right - cRect.left, cRect.bottom - cRect.top);
BMOld = <span class="hljs-keyword">reinterpret_cast</span>&lt;HBITMAP&gt;(SelectObject (DCMem, BMMem));

FillRect (DCMem, &amp;cRect, CreateSolidBrush (RGB (<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>)));

<span class="hljs-comment">//Create the brushes and pens based on the state.</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;state == <span class="hljs-string">&quot;Normal&quot;</span>)
    brush = CreateSolidBrush (RGB (<span class="hljs-number">230</span>,<span class="hljs-number">230</span>,<span class="hljs-number">230</span>));
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;state == <span class="hljs-string">&quot;Hover&quot;</span>)
    brush = CreateSolidBrush (RGB (<span class="hljs-number">200</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>));
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;state == <span class="hljs-string">&quot;Drag&quot;</span>)
    brush = CreateSolidBrush (RGB (<span class="hljs-number">255</span>,<span class="hljs-number">150</span>,<span class="hljs-number">150</span>));
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;state == <span class="hljs-string">&quot;Down&quot;</span>)
    brush = CreateSolidBrush (RGB (<span class="hljs-number">150</span>,<span class="hljs-number">150</span>,<span class="hljs-number">255</span>));

font = CreateFont (-MulDiv (font_size, GetDeviceCaps (DCMem, LOGPIXELSY), <span class="hljs-number">72</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, button_font.c_str ());

SetTextColor (DCMem, RGB (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
SetBkMode (DCMem, TRANSPARENT);
orig_brush = <span class="hljs-keyword">reinterpret_cast</span>&lt;HBRUSH&gt;(SelectObject (DCMem, brush));
orig_pen = <span class="hljs-keyword">reinterpret_cast</span>&lt;HPEN&gt;(SelectObject (DCMem, pen));
orig_font = <span class="hljs-keyword">reinterpret_cast</span>&lt;HFONT&gt;(SelectObject (DCMem, font));

<span class="hljs-comment">//Draw the Button.</span>
Rectangle (DCMem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, cx, cy);
GetTextExtentPoint32 (DCMem, button_text.c_str (), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(button_text.length ()), &amp;tsize);
TextOut (DCMem, (cx - tsize.cx) / <span class="hljs-number">2</span>, (cy - tsize.cy) / <span class="hljs-number">2</span>, button_text.c_str (), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(button_text.length ()));

<span class="hljs-comment">//Off-screen DC.</span>
BitBlt (DC, cRect.left, cRect.top, cRect.right - cRect.left, cRect.bottom - cRect.top, DCMem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SRCCOPY);

SelectObject (DCMem, orig_brush);
SelectObject (DCMem, orig_pen);
SelectObject (DCMem, orig_font);
SelectObject (DCMem, BMOld);
DeleteObject (BMMem);
DeleteDC (DCMem);
DeleteObject (brush);
DeleteObject (pen);
DeleteObject (font);
ReleaseDC (<span class="hljs-keyword">this</span>-&gt;button_wnd, DC);
</div></code></pre>
			<p>
				One of these had to be defined for every distinct component in the
				applications above, along with all their message handlers, and so on.
				Annoying, right?
			</p>
			<h3 id="keylogger">Keylogger</h3>
			<blockquote>
				<p>
					&quot;Motivation is the key to success.&quot;<br />
					- Someone not talking about stealing passwords, probably.
				</p>
			</blockquote>
			<p>
				Knowing that moving forward with GUIs was a very tedious option, I
				looked to the other cool things I could do with programming. Viruses are
				pretty cool too. Here's my first attempt of a keylogger.
			</p>
			<p>
				<video src="emilia.md-assets/keylogger.webm" autoplay loop muted></video
				><br />
				<em
					>Demonstration of the keylogger, which saves its log to a local file
					<code>hi.txt</code>.</em
				>
			</p>
			<p>
				I've attached a snippet of the beginning of the low-level keyboard hook
				function code below.
			</p>
			<pre><code class="language-c++"><div>__declspec(dllexport) <span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">handlekeys</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, WPARAM wp, LPARAM lp)</span>
</span>{
    <span class="hljs-keyword">if</span> (code == HC_ACTION &amp;&amp; (wp == WM_SYSKEYDOWN || wp == WM_KEYDOWN)) {
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> capslock = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> shift = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">0xFF</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str;
        DWORD msg = <span class="hljs-number">1</span>;
        KBDLLHOOKSTRUCT st_hook = *((KBDLLHOOKSTRUCT*)lp);
        <span class="hljs-keyword">bool</span> printable;

        <span class="hljs-comment">/*
         * Get key name as string
         */</span>
        msg += (st_hook.scanCode &lt;&lt; <span class="hljs-number">16</span>);
        msg += (st_hook.flags &lt;&lt; <span class="hljs-number">24</span>);
        GetKeyNameText(msg, tmp, <span class="hljs-number">0xFF</span>);
        str = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(tmp);
</div></code></pre>
			<p>
				There's a bunch of Windows macros as well as fixed-width redefinitions
				of C++ types (<code>DWORD</code> is a 4-byte unsigned integer, I
				believe). The function, hooked into a low-level keyboard hook, would be
				called when any key was pressed (almost, unless another hook is below
				this one, like when Task Manager starts).
			</p>
			<p>
				I had no idea what this code did back then. It was just a mishmash of
				hacks I found online. The full application actually ended up working -
				the only problem was that it stored all the logged keys on a local file.
			</p>
			<h3 id="transferring-keylogs">Transferring keylogs</h3>
			<p>
				Surely it would be too much to ask for me, the hacker, to have to
				transfer files onto a physical USB every time I wanted to see what my
				user had been typing. At the time, I thought the easiest method to
				obtain the logfile from my own computer would have to been through
				email. So I looked online for how to do this. You'll probably find
				similar code if you perform the obvious search.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-comment">// Get the mail service port</span>
lpServEntry = getservbyname(<span class="hljs-string">&quot;mail&quot;</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Use the SMTP default port if no other port is specified</span>
<span class="hljs-keyword">if</span>(!lpServEntry)
    iProtocolPort = htons(IPPORT_SMTP);
<span class="hljs-keyword">else</span>
    iProtocolPort = lpServEntry-&gt;s_port;

<span class="hljs-comment">// Setup a Socket Address structure</span>
SockAddr.sin_family = AF_INET;
SockAddr.sin_port   = iProtocolPort;
SockAddr.sin_addr   = *((LPIN_ADDR)*lpHostEntry-&gt;h_addr_list);

<span class="hljs-comment">// Connect the Socket</span>
<span class="hljs-keyword">if</span>(connect(hServer, (PSOCKADDR) &amp;SockAddr, <span class="hljs-keyword">sizeof</span>(SockAddr)))
{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Error connecting to Server socket&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// Receive initial response from SMTP server</span>
Check(recv(hServer, szBuffer, <span class="hljs-keyword">sizeof</span>(szBuffer), <span class="hljs-number">0</span>), <span class="hljs-string">&quot;recv() Reply&quot;</span>);

<span class="hljs-comment">// Send HELO server.com</span>
<span class="hljs-built_in">sprintf</span>(szMsgLine, <span class="hljs-string">&quot;HELO %s%s&quot;</span>, szSmtpServerName, CRLF);
Check(send(hServer, szMsgLine, <span class="hljs-built_in">strlen</span>(szMsgLine), <span class="hljs-number">0</span>), <span class="hljs-string">&quot;send() HELO&quot;</span>);
Check(recv(hServer, szBuffer, <span class="hljs-keyword">sizeof</span>(szBuffer), <span class="hljs-number">0</span>), <span class="hljs-string">&quot;recv() HELO&quot;</span>);
</div></code></pre>
			<p>
				Knowing what I know now, this code actually might almost work - perhaps
				with a few system-specific adjustments. But back then, I knew nothing
				about what this was doing. Why did it misspell &quot;hello&quot; (of
				course, &quot;EHLO&quot; is an even worse mispelling in that case...)?
			</p>
			<p>
				Of course, there are numerous threads online about sending emails in
				C++. It turns out that it's quite a complicated process. I spent hours
				trying all the code I could find, but none of them worked (or opened up
				Outlook, which a virus definitely does not want to do). Other code used
				pre-built libraries. I remember that I attempted to download some of
				these libraries for my program, but not being able to figure out include
				paths and such. It should be simple, right? Why did I have to download a
				full-fledged library just to send an email?
			</p>
			<p>
				Eventually, I gave up on ever being able to send an email with my C++
				code. Sure, no one wants to give up. But besides Google, I had no one to
				ask for help, and there were no more leads to follow.
			</p>
			<h3 id="rainlibrary0">RainLibrary0</h3>
			<p>
				One of the most influential things to come out of the GUI exploration
				was <code>RainLibrary0</code>. The Rain libraries are a series of
				libraries that build an abstraction layer atop the WinAPI, which makes
				coding future applications much easier. The development of Emilia
				parallels the development of the Rain libraries.
			</p>
			<p>
				Here's a summary of <code>RainLibrary0</code>, the first iteration,
				which was used in <code>Coder</code> and <code>TurboWord</code>. You can
				download it <a href="emilia.md-assets/RainLibrary0.zip">here</a>.
			</p>
			<pre><code><code><div>02/17/14  19:46             5,805 Button.cpp
03/13/14  13:00             1,912 Button.h
08/24/13  13:35            12,102 FileEdit.cpp
08/10/13  16:54             4,046 FileEdit.h
03/30/14  00:32             8,413 ScrollBar.cpp
04/16/14  16:40             1,985 ScrollBar.h
04/16/14  17:02            16,075 SelectionPanel.cpp
04/16/14  17:02             2,802 SelectionPanel.h
08/24/13  13:35            10,777 TextEdit v1.0.cpp
08/11/13  10:37             1,253 TextEdit v1.0.h
09/01/14  19:09            10,351 TextEdit.cpp
05/22/14  06:53             4,555 TextEdit.h
02/14/14  16:49             8,835 Window.cpp
02/08/14  06:33             3,943 Window.h
</div></code></code></pre>
			<h2 id="军旗-luzhanqi-and-sockets">军旗 (Luzhanqi) and Sockets</h2>
			<p>
				Two years later, my father and I were playing 军旗, known as Luzhanqi in
				the states. It's a two-player game, like chess. However, playing 军旗
				often requires a third person: the judge. This is because each player's
				pieces are not revealed to the other player. So when there is a conflict
				between pieces, there must be a judge to look at both pieces and resolve
				the conflict. If a player acted as the judge, he would gain unfair
				information about the other player's pieces.
			</p>
			<p>
				<img src="emilia.md-assets/junqi.jpg" alt="" /><br />
				<em
					>A nice wooden board for 军旗. A given player cannot see the
					opponent's pieces.</em
				>
			</p>
			<p>
				Being an only child, the requirement of a judge meant that every game of
				军旗 would need to engage the entire family. This meant that often,
				because one of my parents were busy, we were unable to play. How great
				would it be if a computer could serve as the judge, so that even if my
				mother were busy, my father and I could still play? This would require
				us to sit at different computers so we couldn't see each others' pieces,
				but we would also need to communicate to each other about the moves we
				were making. Surely there would be a better way to communicate moves
				without yelling to each other and inputting the opponent's moves
				ourselves? I remember distinctly that my father pushing me, saying that
				as a programmer, I should be able to figure it out. Well, here I am,
				dad, writing this tech post.
			</p>
			<h3 id="basic-winsock">Basic Winsock</h3>
			<p>
				It must've been this <strong>cross-communication</strong> focus rather
				than email focus that led me to the solution. Because general socket
				communications are so much easier to implement than the SMTP protocol,
				my Google skills were able to lead me to the solution. Unfortunately, I
				was not aware of the ease of sockets compared to SMTP when I was
				implementing my keylogger. I wrote winsock code like the following into
				my program:
			</p>
			<pre><code class="language-c++"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitSocket</span> <span class="hljs-params">(SOCKET &amp;s)</span>
</span>{
    s = socket (AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (s == INVALID_SOCKET)
        ErrorAndExit ();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BindSocket</span> <span class="hljs-params">(SOCKET &amp;s)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span>
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons (<span class="hljs-number">8888</span>);

    <span class="hljs-keyword">if</span> (bind (s, (struct sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span> (server)) == SOCKET_ERROR)
        ErrorAndExit ();
}
</div></code></pre>
			<p>
				After setting up the sockets and listening, my local client was able to
				connect to my local server. However, when I moved the server to my
				father's computer, I was unable to connect. It turns out that I would
				have to deal with this problem numerous times going forward.
			</p>
			<p>
				The reason I was unable to connect was because the antivirus on my
				father's computer had blocked outgoing connections through shady
				programs (like mine, I suppose). This definitely took some thinking to
				find, and once we added a rule through the antivirus, the program was
				able to connect as expected. We were able to send messages to each
				other, like a 1-1 messaging system! Unfortunately, I never finished the
				game. This is as far as I got:
			</p>
			<pre><code class="language-c++"><div>SOCKET s, new_socket;

InitWSA ();
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;WSA Initialized...\n&quot;</span>;
InitSocket (s);
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Socket Initialized...\n&quot;</span>;
BindSocket (s);
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Socket Binded...\n&quot;</span>;
ListenSocket (s);
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Listening Initialized...\n&quot;</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Local IP: &quot;</span> &lt;&lt; GetLocIP () &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
AcceptConnection (s, new_socket);
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Connection Initialized...\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;Stream is open, enter \&quot;exit\&quot; to end connection.\n&quot;</span>;

<span class="hljs-built_in">string</span> text;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
{
    getline (<span class="hljs-built_in">cin</span>, text);
    SendToSocket (new_socket, text);

    <span class="hljs-keyword">if</span> (text == <span class="hljs-string">&quot;exit&quot;</span>)
        <span class="hljs-keyword">break</span>;
}

CloseSocket (s);
EndWSA ();
</div></code></pre>
			<p>
				It's not much, but it turns out game logic is difficult to write. And
				what if the other player was able to inject packages pretending to be my
				application to make illegal moves? I'd have to check that, and design a
				way to deal with that, and deal with inconsistent network connections,
				and find out how I would connect to external IPs instead of internal...
			</p>
			<p>
				<video src="emilia.md-assets/junqi.webm" autoplay loop muted></video
				><br />
				<em
					>Connecting the client to the server, and having the server send
					messages to the client.</em
				>
			</p>
			<p>
				However, this 军旗 application was a major step forward for me. This is
				the first time I was able to set up communications between two computers
				on the network (albeit, local). But I knew nothing about the big, vast
				IP network out there and how to communicate with it. Neither did I have
				the motivation to do so, when a browser would work just fine. It took me
				another three years to take my first step onto the web.
			</p>
			<h3 id="rainlibrary1">RainLibrary1</h3>
			<p>
				The development of the 军旗 application, among other things, led to the
				development of <code>RainLibrary1</code>, which contained much of the
				boilerplate code to setup WSA/winsock. Here's the summary of the library
				(which is in general not backwards-compatible):
			</p>
			<pre><code><code><div>02/17/14  19:46             5,805 Button.cpp
03/13/14  13:00             1,912 Button.h
11/20/16  18:55               167 ErrorReport.cpp
01/01/17  23:02               213 ErrorReport.h
01/01/17  22:37               369 FastFileIO.cpp
01/01/17  22:27               181 FastFileIO.h
08/24/13  13:35            12,102 FileEdit.cpp
08/10/13  16:55             4,046 FileEdit.h
11/21/16  02:44                27 GdiplusInclude.cpp
01/01/17  23:05               191 GdiplusInclude.h
01/01/17  22:36               442 RainError.cpp
01/01/17  22:27               228 RainError.h
11/21/16  18:01             3,886 RainWindow.cpp
01/01/17  22:42             2,218 RainWindow.h
11/17/16  20:49             4,081 RainWSA2.cpp
01/01/17  23:02             1,381 RainWSA2.h
03/30/14  00:32             8,413 ScrollBar.cpp
04/16/14  16:40             1,985 ScrollBar.h
04/16/14  17:02            16,075 SelectionPanel.cpp
04/16/14  17:02             2,802 SelectionPanel.h
11/17/16  20:34             1,202 SendRecv.cpp
01/01/17  23:02               915 SendRecv.h
07/06/16  23:26             2,328 SRHBase.cpp
01/01/17  23:02               594 SRHBase.h
08/24/13  13:35            10,777 TextEdit v1.0.cpp
08/11/13  10:37             1,253 TextEdit v1.0.h
09/01/14  19:09            10,351 TextEdit.cpp
05/22/14  06:53             4,555 TextEdit.h
12/31/16  14:15             9,492 Utility.cpp
01/01/17  22:42             1,596 Utility.h
02/14/14  16:49             8,835 Window.cpp
01/01/17  23:02             3,965 Window.h
01/01/17  22:41                30 WindowsLAMInclude.cpp
01/01/17  22:29               213 WindowsLAMInclude.h
11/21/16  10:56                24 WSA2Include.cpp
01/01/17  23:04               431 WSA2Include.h
01/01/17  22:21               502 WSA2RecvParam.cpp
01/01/17  23:03               688 WSA2RecvParam.h
01/01/17  23:03             7,848 WSA2Utility.cpp
01/01/17  23:04             3,853 WSA2Utility.h
</div></code></code></pre>
			<p>
				As you can see, there's a lot more files here. There are many more files
				for basic GUI controls, as well as a flurry of files dealing with WSA.
				Here's the <a href="emilia.md-assets/RainLibrary1.zip">download</a>.
			</p>
			<h2 id="the-pixiv-breakthrough">The Pixiv Breakthrough</h2>
			<p>
				<img src="emilia.md-assets/pixiv.jpg" alt="" /><br />
				<em
					>The website found at
					<a
						href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=72190967"
						>https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=72190967</a
					>.</em
				>
			</p>
			<p>
				Pixiv is a Japanese website for artists to share their work. It attracts
				mainly artists who draw anime-style art. Most anime images that you can
				find online can likely have their source traced back to Pixiv, one way
				or another. So if I were trying to find the most beautiful anime-style
				pictures, then starting at Pixiv would be a good bet.
			</p>
			<p>
				Roughly, each image page like the above consists of an image, some
				recommendations for similar images, and a bunch of other stuff I didn't
				care about. Back in 2016, the recommendations would have also been more
				diverse, containing images from other artists as well. It's a shame they
				removed that recommender from the UI a while ago. Clicking on the main
				image would give you a special page with the full version of the image,
				from where clicking &quot;Save As...&quot; on a typical browser would
				allow you to save the full version. &quot;Save As...&quot; from the page
				shown above would give you a &quot;master&quot; version of the image,
				which sometimes would not be the highest quality available.
			</p>
			<p>
				For a while, I would browse and download images manually with the Chrome
				browser by clicking open each image I liked, clicking open its full
				version, saving that, and iterating on its recommendations. Back in
				2016, Pixiv was extremely inefficient with resources, and the browser
				would crash at around 10 tabs or so, rendering a lot of my time spent
				waiting around.
			</p>
			<p>
				Unfortunately, Pixiv has since changed its API, and my code no longer
				works, so I will not be able to showcase any images/GIFs in this
				section.
			</p>
			<h3 id="request-imitation-with-chrome">Request Imitation with Chrome</h3>
			<p>
				This was also the year that I interned at my first company, Lucid
				Software. There, I learned to debug webapps using the Chrome debugger.
				One of the techniques for debugging is looking at the Network tab, which
				would show all the requests that the browser would send to the webserver
				and the responses as well, including the headers. If the browser could
				send these requests, could I also send these requests, and even automate
				all the clicking on Pixiv's website?
			</p>
			<p>
				<img src="emilia.md-assets/pixiv-network.jpg" alt="" /><br />
				<em
					>Chrome's Network tab, showing the headers of both the request and
					response for the main page above.</em
				>
			</p>
			<p>
				It was also at this internship that I learned to use Selenium, a library
				to control web browsers through code. While Selenium would have
				definitely been the easier way to go for this scraping project, it
				didn't feel <em>clean</em>. It loaded too much unnecessary stuff in the
				background, and couldn't control multiple tabs at once, and would
				display an ugly browser in the background to process the images (I
				didn't know about <code>headless</code> mode back then). Doing it in
				C++, I could fully customize what I wanted and didn't want, and how it
				was shown to me and how it was stored. I suppose this is probably the
				point of no return, where I abandoned the thought of using pre-built
				libraries to browse the web but instead to code it all from scratch. In
				hindsight, I wish I had given the other option more consideration. But
				reinventing the wheel turned out okay, I think.
			</p>
			<p>
				Knowing what I knew about sockets, I set out to try to send some
				requests to Pixiv.
			</p>
			<pre><code class="language-c++"><div>Rain::WSARecvParam *recvparam = <span class="hljs-keyword">new</span> Rain::WSARecvParam ();
MRSIParam *mrsiparam = <span class="hljs-keyword">new</span> MRSIParam ();
mrsiparam-&gt;conn = <span class="hljs-keyword">new</span> SOCKET ();

<span class="hljs-keyword">if</span> (Rain::CreateClientSocket (uparam-&gt;psaddr, *(mrsiparam-&gt;conn)))
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
<span class="hljs-keyword">if</span> (Rain::ConnToServ (uparam-&gt;psaddr, *(mrsiparam-&gt;conn)))
    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> getreq;
getreq = <span class="hljs-string">&quot;GET /member_illust.php?mode=medium&amp;illust_id=&quot;</span> + Rain::IntToStr (code) + <span class="hljs-string">&quot; HTTP/1.1\nHost: www.pixiv.net\n&quot;</span> + (*(uparam-&gt;header))[(*(uparam-&gt;safe))][<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;\n&quot;</span>;

recvparam-&gt;OnRecvEnd = OnMRSIExit;
mrsiparam-&gt;code = code;

PrepMRSIParams (mrsiparam, recvparam, uparam);

Rain::SendText (*(mrsiparam-&gt;conn), getreq.c_str (), getreq.length ());
</div></code></pre>
			<p>
				The code above sets up some pointers to establish new parameters first,
				to pass to the thread once a connection is established with the server.
				Somewhere else in the code, we would call <code>recv</code>, and then
				pass the parameters declared here to the handlers to handle the buffer
				returned from <code>recv</code>. The rest of the code here creates the
				<code>GET</code> request, sets the <code>recv</code> handlers, and sends
				the request to the established socket.
			</p>
			<p>
				Getting the first reply back from Pixiv was perhaps one of the most
				exhilarating events I've ever experienced. I remember it was a 400
				error, as expected; but even hearing anything back from within my
				program was a success to me. I had figured out how to target a webserver
				and send a response. I was quickly able to observe the differences
				between my request and Chrome's, modify my code, and receive a 200
				(success) response.
			</p>
			<h3 id="response-parsing">Response &quot;Parsing&quot;</h3>
			<p>
				From that point forward, it was a simple matter of string parsing and
				saving the image from there.
			</p>
			<pre><code class="language-c++"><div>MRSIParam *mrsiparam = <span class="hljs-keyword">reinterpret_cast</span>&lt;MRSIParam *&gt;(param);
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;fmess = *(mrsiparam-&gt;fmess);

DecCacheThread (mrsiparam-&gt;uparam);

<span class="hljs-keyword">if</span> (fmess.length () == <span class="hljs-number">0</span>)
{
    mrsiparam-&gt;uparam-&gt;mcout.lock ();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;MarkRequestStoreImage request returned empty, retrying\n&quot;</span>;
    mrsiparam-&gt;uparam-&gt;mcout.unlock ();
    MarkRequestStoreImage (mrsiparam-&gt;code, mrsiparam-&gt;uparam);
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-comment">//check safety because recommender doesn&#x27;t do that</span>
    <span class="hljs-keyword">if</span> ((*mrsiparam-&gt;uparam-&gt;safe &amp;&amp; fmess.find (<span class="hljs-string">&quot;Access by users under age 18 is restricted.&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) || <span class="hljs-comment">//check for private works</span>
        (fmess.find (<span class="hljs-string">&quot;Artist has made their work private.&quot;</span>) != <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos))
    {
        mrsiparam-&gt;uparam-&gt;munivparam.lock ();
        mrsiparam-&gt;uparam-&gt;inqueue-&gt;erase (mrsiparam-&gt;code);
        mrsiparam-&gt;uparam-&gt;processed-&gt;insert (mrsiparam-&gt;code);
        mrsiparam-&gt;uparam-&gt;munivparam.unlock ();

        PostMessage (mrsiparam-&gt;uparam-&gt;imagewnd-&gt;hwnd, RAIN_IMAGECHANGE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        FreeAndCloseMRSI (mrsiparam);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">//parse fmess for original image(s)</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> orig = fmess.find (<span class="hljs-string">&quot;_illust_modal _hidden ui-modal-close-box&quot;</span>);

    <span class="hljs-keyword">if</span> (orig == <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::npos) <span class="hljs-comment">//is a manga/multiple image submission</span>
        MarkParseMangaSubmission (mrsiparam-&gt;code, mrsiparam-&gt;uparam);
    <span class="hljs-keyword">else</span> <span class="hljs-comment">//single image submission</span>
    {
        <span class="hljs-comment">//create vector in bsfq for image name storage</span>
        mrsiparam-&gt;uparam-&gt;munivparam.lock ();
        mrsiparam-&gt;uparam-&gt;bfsq-&gt;push (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">make_pair</span> (mrsiparam-&gt;code, <span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; ()));
        mrsiparam-&gt;uparam-&gt;inqueue-&gt;insert (mrsiparam-&gt;code);
        mrsiparam-&gt;uparam-&gt;munivparam.unlock ();

        orig = fmess.find (<span class="hljs-string">&quot;data-src=\&quot;&quot;</span>, orig) + <span class="hljs-number">10</span>;
        MarkDownloadSingleImage (fmess.substr (orig, fmess.find (<span class="hljs-string">&quot;\&quot;&quot;</span>, orig) - orig), <span class="hljs-string">&quot;http://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=&quot;</span> + Rain::IntToStr (mrsiparam-&gt;code), mrsiparam-&gt;uparam-&gt;bfsq-&gt;back ().second, mrsiparam-&gt;uparam);
    }
}

FreeAndCloseMRSI (mrsiparam);
</div></code></pre>
			<p>
				The earlier parts of this code translates the parameters packaged from
				before into usable pointers. Then, it manages the threadpool, removing
				the current thread from it, since we're going to cache the image now and
				close the connection soon.
			</p>
			<p>
				The rest of my first HTML parser is about what you might expect. I hone
				in straight on the image link with a <code>find</code> on the response
				string, check for some common errors from Pixiv, and send out another
				request based on the image link. If the image link is a
				&quot;manga&quot; image, then I'll need to parse it further; otherwise,
				I can just request the image file directly from pixiv now that I know
				its URL.
			</p>
			<p>
				At first, image file requests would fail, but I eventually learned from
				more Chrome observing and some testing with the Advanced REST Client
				(ARC) that I had to send a <code>Referer</code> header with my requests
				lest they be rejected. I also observed that the <code>_tt</code> header
				contained a token representing my account. From this, I even built a
				switch to reject R-18 images by simply creating two accounts on Pixiv,
				and setting one of them as R-18. Then, by sending the request with one
				<code>_tt</code> header or another, I was able to detect which images
				were R-18, and filther them out accordingly (or not, haha). You can also
				see this in the code above.
			</p>
			<h3 id="recommender">Recommender</h3>
			<p>
				However, I hit a roadbump when I tried to look for recommended images.
				While they're clearly visible in Chrome, nowhere in the Network tab did
				I spot a request for those images. It turns out that even with
				&quot;Disable cache&quot; checked, Chrome would still cache the
				recommended images in another site cache. By clearing that every time I
				needed to verify my code, I was able to view the call to the recommender
				API, and imitate that within my program.
			</p>
			<pre><code class="language-c++"><div>Rain::WSARecvParam *recvparam = <span class="hljs-keyword">new</span> Rain::WSARecvParam ();
MRSIParam *mrsiparam = <span class="hljs-keyword">new</span> MRSIParam ();
mrsiparam-&gt;conn = <span class="hljs-keyword">new</span> SOCKET ();

<span class="hljs-keyword">if</span> (Rain::CreateClientSocket (uparam-&gt;psaddr, *(mrsiparam-&gt;conn)))
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
<span class="hljs-keyword">if</span> (Rain::ConnToServ (uparam-&gt;psaddr, *(mrsiparam-&gt;conn)))
    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> getreq;
getreq = <span class="hljs-string">&quot;GET /rpc/recommender.php?type=illust&amp;sample_illusts=&quot;</span> + Rain::IntToStr (code) + <span class="hljs-string">&quot;&amp;num_recommendations=&quot;</span> + Rain::IntToStr (*uparam-&gt;reccount) + <span class="hljs-string">&quot;&amp;tt=&quot;</span> + (*uparam-&gt;tt)[(*(uparam-&gt;safe))] + <span class="hljs-string">&quot; HTTP/1.1\nHost: www.pixiv.net\nReferer: http://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=&quot;</span> + Rain::IntToStr (code) + <span class="hljs-string">&quot;\n&quot;</span> + (*(uparam-&gt;header))[(*(uparam-&gt;safe))][<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;\n&quot;</span>;

mrsiparam-&gt;code = code;
recvparam-&gt;OnRecvEnd = OnMRSRExit;

PrepMRSIParams (mrsiparam, recvparam, uparam);

Rain::SendText (*(mrsiparam-&gt;conn), getreq.c_str (), getreq.length ());
</div></code></pre>
			<p>
				As you can probably see, the requests are becoming more and more
				confusing for the developer. That big mess of a line with
				<code>getreq</code> actually worked, but was definitely not something I
				wanted to try to debug in the future, if any of their API changed.
			</p>
			<h3 id="automated-versioning">Automated Versioning</h3>
			<p>
				Another important development with <code>PixivBot</code> was automated
				build versioning. By setting the following batch file as a Pre-Build
				Event in Visual Studio, I was able to increment a number in the
				VersionBuildInc.h file each time I built which would be imported
				indirectly into my resource file and appended to my program metadata.
			</p>
			<h4 id="buildbat">build.bat</h4>
			<pre><code class="language-bat"><div>@<span class="hljs-built_in">echo</span> off
<span class="hljs-built_in">setlocal</span> enabledelayedexpansion
<span class="hljs-built_in">set</span> filename=../rc/build.h
<span class="hljs-keyword">if</span> <span class="hljs-keyword">exist</span> &quot;<span class="hljs-variable">%filename%</span>.temp&quot; <span class="hljs-built_in">del</span> &quot;<span class="hljs-variable">%filename%</span>.temp&quot;
<span class="hljs-keyword">for</span> /F &quot;tokens=*&quot; <span class="hljs-variable">%%R</span> <span class="hljs-keyword">in</span> (<span class="hljs-variable">%filename%</span>) <span class="hljs-keyword">do</span> (
    <span class="hljs-keyword">if</span> &quot;<span class="hljs-variable">%%R</span>&quot;==&quot;&quot; <span class="hljs-built_in">echo</span>. &gt;&gt; &quot;<span class="hljs-variable">%filename%</span>.temp&quot;
    <span class="hljs-built_in">set</span> incflag=<span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> /f &quot;tokens=<span class="hljs-number">1</span>-<span class="hljs-number">3</span> delims= &quot; <span class="hljs-variable">%%A</span> <span class="hljs-keyword">in</span> (&quot;<span class="hljs-variable">%%R</span>&quot;) <span class="hljs-keyword">do</span> (
        <span class="hljs-keyword">if</span> &quot;<span class="hljs-variable">%%B</span>&quot;==&quot;VERSION_BUILD&quot; <span class="hljs-built_in">set</span> incflag=<span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> <span class="hljs-variable">!incflag!</span> <span class="hljs-keyword">equ</span> <span class="hljs-number">1</span> (
            <span class="hljs-built_in">set</span> /a num=<span class="hljs-variable">%%C</span>+<span class="hljs-number">1</span>
            <span class="hljs-built_in">echo</span> <span class="hljs-variable">%%A</span> <span class="hljs-variable">%%B</span>            <span class="hljs-variable">!num!</span>&gt;&gt; &quot;<span class="hljs-variable">%filename%</span>.temp&quot;
        ) <span class="hljs-keyword">else</span> (
            <span class="hljs-built_in">echo</span> <span class="hljs-variable">%%R</span>&gt;&gt; &quot;<span class="hljs-variable">%filename%</span>.temp&quot;
        )
    )
)
<span class="hljs-built_in">del</span> &quot;<span class="hljs-variable">%filename%</span>&quot;
<span class="hljs-built_in">ren</span> &quot;<span class="hljs-variable">%filename%</span>.temp&quot; &quot;<span class="hljs-variable">%filename%</span>&quot;
</div></code></pre>
			<p>
				I didn't write the batch file myself, but instead found it on the
				internet. The file looks for a line containing the
				<code>BUILD_INCREMENT</code> token, takes the number after that token,
				and increments it by one.
			</p>
			<h4 id="versionbuildinch">VersionBuildInc.h</h4>
			<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUILD_INCREMENT 797</span>
</div></code></pre>
			<p>This is the file which would be incremented by the batch file.</p>
			<h4 id="versionidh">VersionID.h</h4>
			<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;VersionBuildInc.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRINGIZE2(s) #s</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRINGIZE(s) STRINGIZE2(s)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRINGIZE2(s) #s</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRINGIZE(s) STRINGIZE2(s)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_MAJOR            1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_MINOR            1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_REVISION         3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_BUILD            BUILD_INCREMENT</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_FILE_DESCRIPTION_STR <span class="hljs-meta-string">&quot;PixivBot&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_FILE_VERSION         VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_BUILD</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_FILE_VERSION_STR     STRINGIZE(VERSION_MAJOR)     \
                                    <span class="hljs-meta-string">&quot;.&quot;</span> STRINGIZE(VERSION_MINOR) \
                                    <span class="hljs-meta-string">&quot;.&quot;</span> STRINGIZE(VERSION_REVISION) \
                                    <span class="hljs-meta-string">&quot;.&quot;</span> STRINGIZE(VERSION_BUILD) \
</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_PRODUCTNAME_STR      VER_FILE_DESCRIPTION_STR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_PRODUCT_VERSION      VER_FILE_VERSION</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_PRODUCT_VERSION_STR  VER_FILE_VERSION_STR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_ORIGINAL_FILENAME_STR   VER_PRODUCTNAME_STR <span class="hljs-meta-string">&quot;.exe&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_INTERNAL_NAME_STR    VER_ORIGINAL_FILENAME_STR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VER_COPYRIGHT_STR        <span class="hljs-meta-string">&quot;Yang Yan&quot;</span></span>
</div></code></pre>
			<p>
				This header defines more macros based on the
				<code>BUILD_INCREMENT</code> modified by the batch file above.
			</p>
			<h4 id="resourcerc">resource.rc</h4>
			<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;resource.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;VersionID.h&quot;</span></span>

VS_VERSION_INFO VERSIONINFO
FILEVERSION     VER_FILE_VERSION
PRODUCTVERSION  VER_PRODUCT_VERSION
FILEFLAGSMASK   <span class="hljs-number">0x3f</span>L
FILEFLAGS       VER_FILEFLAGS
FILEOS          VER_FILEOS
FILETYPE        VER_FILETYPE
FILESUBTYPE     <span class="hljs-number">0x0</span>L
BEGIN
BLOCK <span class="hljs-string">&quot;StringFileInfo&quot;</span>
BEGIN
BLOCK <span class="hljs-string">&quot;040904b0&quot;</span>
BEGIN
VALUE <span class="hljs-string">&quot;FileDescription&quot;</span>, VER_FILE_DESCRIPTION_STR <span class="hljs-string">&quot;\0&quot;</span>
VALUE <span class="hljs-string">&quot;FileVersion&quot;</span>, VER_FILE_VERSION_STR <span class="hljs-string">&quot;\0&quot;</span>
VALUE <span class="hljs-string">&quot;InternalName&quot;</span>, VER_INTERNAL_NAME_STR <span class="hljs-string">&quot;\0&quot;</span>
VALUE <span class="hljs-string">&quot;LegalCopyright&quot;</span>, VER_COPYRIGHT_STR <span class="hljs-string">&quot;\0&quot;</span>
VALUE <span class="hljs-string">&quot;OriginalFilename&quot;</span>, VER_ORIGINAL_FILENAME_STR <span class="hljs-string">&quot;\0&quot;</span>
VALUE <span class="hljs-string">&quot;ProductName&quot;</span>, VER_PRODUCTNAME_STR
VALUE <span class="hljs-string">&quot;ProductVersion&quot;</span>, VER_PRODUCT_VERSION_STR <span class="hljs-string">&quot;\0&quot;</span>
END
END
BLOCK <span class="hljs-string">&quot;VarFileInfo&quot;</span>
BEGIN
VALUE <span class="hljs-string">&quot;Translation&quot;</span>, <span class="hljs-number">0x409</span>, <span class="hljs-number">1200</span>
END
END
</div></code></pre>
			<p>
				As mentioned, the resource file here imports the version information and
				saves it in a block into the generated EXE. Here's what it looks like:
			</p>
			<p>
				<img src="emilia.md-assets/pixivbot-version.jpg" alt="" /><br />
				<em>Version information visible in the built EXE.</em>
			</p>
			<p>
				I learned to optimize this routine later on, but automatic build
				versioning would stay with Emilia moving forward.
			</p>
			<h3 id="rainlibrary2">RainLibrary2</h3>
			<p>
				The <code>1.1.3</code> version of <code>PixivBot</code> once again
				iterated on the Rain library. Earlier versions used
				<code>RainLibrary1</code>. Here's the summary of
				<code>RainLibrary2</code>:
			</p>
			<pre><code><code><div>03/04/18  08:20               432 RainError.cpp
03/04/18  08:20               227 RainError.h
01/01/17  23:12                31 RainGdiplusInclude.cpp
01/01/17  23:37               218 RainGdiplusInclude.h
01/01/17  22:39                26 RainLibraries.cpp
03/04/18  08:46               404 RainLibraries.h
03/04/18  08:20               667 RainLogging.cpp
03/04/18  08:20             2,084 RainLogging.h
03/04/18  08:20             4,313 RainUtility.cpp
03/04/18  08:20             1,077 RainUtility.h
03/04/18  08:20             5,167 RainUtilityFile.cpp
03/04/18  08:46             1,586 RainUtilityFile.h
03/04/18  08:21             3,811 RainWindow.cpp
03/04/18  08:21             2,206 RainWindow.h
01/01/17  23:12                27 RainWindowsLAM.cpp
01/01/17  22:29               213 RainWindowsLAM.h
01/01/17  23:21                21 RainWSA2.cpp
01/02/17  00:04               125 RainWSA2.h
01/01/17  23:22                28 RainWSA2Include.cpp
03/04/18  08:26               294 RainWSA2Include.h
03/04/18  08:21             3,489 RainWSA2SendRecv.cpp
03/04/18  08:21             2,141 RainWSA2SendRecv.h
03/04/18  08:19             4,253 RainWSA2Utility.cpp
03/04/18  08:15             1,165 RainWSA2Utility.h
</div></code></code></pre>
			<p>
				<code>RainLibrary2</code> moves away from the older GUI routines and
				focuses on console routines. The GUI routines were not up-to-date with
				my newest programming philosophies and not commonly used, so they were
				not incorporated into future Rain libraries.
				<a href="emilia.md-assets/RainLibrary2.zip">Here's the download</a>.
			</p>
			<h2 id="monochrome-2--3">Monochrome 2 &amp; 3</h2>
			<p>
				<code>PixivBot</code> was a network client, and servers are a different
				beast. Knowing now that I could connect with remote servers with
				Winsock, I dove out to try to write a server of my own which, instead of
				imitating the client-side requests that I saw in Chrome, would imitate
				the server-side responses. I wrote my first webserver in C++ as the
				third (2, because we're coders) program of a series of experimental
				programs I called Monochrome.
			</p>
			<p>
				This is the main code responsible for <code>Monochrome2</code>, beyond
				the Rain library code. <code>Monochrome2</code> uses
				<code>RainLibrary1</code>. The code below contains most of the logic
				surrounding handling new connections to the server and sending bytes.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Main.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> error;
    WSADATA wsadata;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">saddr</span>;</span>
    SOCKET listen;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> tmp, port;

    atexit (Mono2::OnExit);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Server port (default HTTP, 80): &quot;</span>;
    <span class="hljs-built_in">std</span>::getline (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, port);

    error = Rain::InitWinsock (wsadata);
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> error;
    error = Rain::GetServAddr (port, &amp;saddr);
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> error;
    error = Rain::CreateServLSocket (&amp;saddr, listen);
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> error;
    error = Rain::BindServLSocket (&amp;saddr, listen);
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> error;
    error = Rain::ListenServSocket (listen);
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> error;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Listening on port &quot;</span> &lt;&lt; port &lt;&lt; <span class="hljs-string">&quot;...\n&quot;</span>;

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;SOCKET *&gt; client;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Rain::RecvParam *&gt; recvparam;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Mono2::FuncParam *&gt; funcparam;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;HANDLE&gt; recvthread;
    <span class="hljs-keyword">int</span> requestnum = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
        client.push_back (<span class="hljs-keyword">new</span> SOCKET ());
        error = Rain::ServAcceptClient (*client.back (), listen);
        <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> error;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Client accepted!\n&quot;</span>;

        recvparam.push_back (<span class="hljs-keyword">new</span> Rain::RecvParam ());
        funcparam.push_back (<span class="hljs-keyword">new</span> Mono2::FuncParam ());
    
        recvparam.back ()-&gt;sock = client.back ();
        recvparam.back ()-&gt;message = &amp;funcparam.back ()-&gt;message;
        recvparam.back ()-&gt;buflen = <span class="hljs-number">1024</span>;
        recvparam.back ()-&gt;funcparam = funcparam.back ();
        recvparam.back ()-&gt;ProcessMessage = Mono2::ProcMess;
        recvparam.back ()-&gt;OnRecvEnd = Mono2::OnRecvEnd;

        funcparam.back ()-&gt;sock = client.back ();
        funcparam.back ()-&gt;requestnum = &amp;requestnum;

        recvthread.push_back (HANDLE ());
        recvthread.back () = CreateThread (<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, Rain::RecvThread, recvparam.back (), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
    }

    <span class="hljs-comment">//this point won&#x27;t be reached. Check OnExit (atexit).</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">namespace</span> Mono2
{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ProcMess</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *param)</span>
    </span>{
        Mono2::FuncParam &amp;fparam = *<span class="hljs-keyword">reinterpret_cast</span>&lt;Mono2::FuncParam *&gt;(param);

        fparam.fmess += fparam.message;
        <span class="hljs-keyword">if</span> (fparam.fmess.substr (fparam.fmess.size () - <span class="hljs-number">4</span>, <span class="hljs-number">4</span>) == <span class="hljs-string">&quot;\r\n\r\n&quot;</span>) <span class="hljs-comment">//GET is done</span>
        {
            <span class="hljs-comment">//std::cout &lt;&lt; fparam.fmess;</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;GET request #&quot;</span> &lt;&lt; ++(*fparam.requestnum) &lt;&lt; <span class="hljs-string">&quot; received! Replying...\n&quot;</span>;

            <span class="hljs-keyword">time_t</span> rawtime;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">timeinfo</span>;</span>
            <span class="hljs-keyword">char</span> *timestr;
            time (&amp;rawtime);
            timeinfo = localtime (&amp;rawtime);
            timestr = asctime (timeinfo);

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> htmlpage;
            <span class="hljs-built_in">std</span>::ifstream in;
            htmlpage &lt;&lt; <span class="hljs-string">&quot;&lt;html&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;head&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;title&gt;Welcome to Emilia-tan!&lt;/title&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;link href=\&quot;data:image/x-icon;base64,&quot;</span>;

            in.open (<span class="hljs-string">&quot;base64emiliafavicon.txt&quot;</span>, <span class="hljs-built_in">std</span>::ios::binary);
            htmlpage &lt;&lt; in.rdbuf ();
            in.close ();
            
            htmlpage &lt;&lt; <span class="hljs-string">&quot;\&quot; rel=\&quot;icon\&quot; type=\&quot;image/x-icon\&quot; /&gt;&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;/head&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;body&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;Welcome to Emilia-tan!&lt;br&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;This is WPI website run and hosted by Gilgamesh. All requests and inqueries can be emailed to gilgamesh@tfwno.gf (yes, setting up a SMTP server on here is difficult).&lt;br&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;br&gt;Emilia-tan is hosted on a private server.&lt;br&gt;\r\n&quot;</span> &lt;&lt; 
                <span class="hljs-string">&quot;The server runs on \&quot;Rain Server Monochrome02\&quot;, or \&quot;Mono2\&quot;, written in native C++ &amp; Windows &amp; Winsock2 API by Gilgamesh.&lt;br&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;br&gt;FileExplorer has been implemented, but has yet to be linked to the Mono2 server.&lt;br&gt;\r\n&quot;</span> &lt;&lt; 
                <span class="hljs-string">&quot;For now, have these cute gifs of our savior, &lt;a href=\&quot;waifu.emilia-tan.com\&quot;&gt;Emilia-sama&lt;/a&gt;! (encoded in base64)&lt;br&gt;\r\n&quot;</span> &lt;&lt; 
                <span class="hljs-string">&quot;&lt;img src=\&quot;data:image/gif;base64,&quot;</span>;

            in.open (<span class="hljs-string">&quot;base64emiliagif.txt&quot;</span>, <span class="hljs-built_in">std</span>::ios::binary);
            htmlpage &lt;&lt; in.rdbuf ();
            in.close ();

            htmlpage &lt;&lt; <span class="hljs-string">&quot;\&quot; /&gt;&lt;br&gt;\r\n&quot;</span> &lt;&lt; 
                <span class="hljs-string">&quot;&lt;br&gt;Once again, welcome to Emilia-tan!&lt;br&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;If you&#x27;re curious, you can find the code to the Mono2 server here.&lt;br&gt;\r\n&quot;</span> &lt;&lt; 
                <span class="hljs-string">&quot;This is GET request #&quot;</span> &lt;&lt; (*fparam.requestnum) &lt;&lt; <span class="hljs-string">&quot;. The server time is &quot;</span> &lt;&lt; timestr &lt;&lt;
                <span class="hljs-string">&quot;&lt;/body&gt;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>;

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> respss;
            respss &lt;&lt; <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> &lt;&lt;
                <span class="hljs-comment">//&quot;Date: &quot; &lt;&lt; timestr &lt;&lt; &quot;\r\n&quot; &lt;&lt;</span>
                <span class="hljs-string">&quot;Content-Type: text/html; charset = UTF-8\r\n&quot;</span> &lt;&lt; 
                <span class="hljs-string">&quot;Content-Encoding: UTF-8\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;Content-Length: &quot;</span> &lt;&lt; htmlpage.str ().length () &lt;&lt; <span class="hljs-string">&quot;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-comment">//&quot;Last-Modified: Wed, 08 Jan 2003 23:11 : 55 GMT\r\n&quot; &lt;&lt;</span>
                <span class="hljs-string">&quot;Server: Rain Server Monochrome02\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;ETag: \&quot;&quot;</span> &lt;&lt; rawtime &lt;&lt; <span class="hljs-string">&quot;\&quot;\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;Accept-Ranges: bytes\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;Connection: close\r\n&quot;</span> &lt;&lt;
                <span class="hljs-string">&quot;\r\n&quot;</span> &lt;&lt;
                htmlpage.rdbuf ();
            Rain::SendText (*fparam.sock, respss.str ().c_str (), respss.str ().length ());

            <span class="hljs-comment">//close connection now</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRecvEnd</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *param)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Client terminating...\n&quot;</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnExit</span> <span class="hljs-params">()</span>
    </span>{<span class="hljs-comment">/*
        WaitForSingleObject (recvthread, INFINITE);
        derror = CloseHandle (recvthread);
        error = Rain::ShutdownSocketSend (client);
        if (error) return error;
        closesocket (client);
        closesocket (listen);*/</span>
        WSACleanup ();

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Main thread exiting...\n&quot;</span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> tmp;
        <span class="hljs-built_in">std</span>::getline (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, tmp);
    }
}
</div></code></pre>
			<p>
				It might look quite long, but it's pretty short for a C++ webserver.
				<code>Monochrome2</code> ignored the entire request that it would
				receive. Instead, it would send back a static HTML string (which you can
				see in the code above) each time, on each connection, then close it
				immediately.
			</p>
			<p>
				At the same time, I registered the domain name
				<code>emilia-tan.com</code>, pointed it to my home IP, and linked my
				external port 80 to my internal port 80 and suddenly (after more
				firewall/router tweaking) my website was viewable online. I could access
				it with any web browser from anywhere, and see the plaintext I had sent
				back with my program.
			</p>
			<p>
				This is also the landmark when the name <code>Emilia</code> became used.
				At this point, however, the webserver was still called
				<code>Monochrome2</code>. Below is a GIF showing the webserver in
				action.
			</p>
			<p>
				<video src="emilia.md-assets/mono-2.webm" autoplay loop muted></video
				><br />
				<em
					>Start the webserver, and refresh the page a few times to see an
					in-memory counter increase.</em
				>
			</p>
			<p>
				One of the most annoying problems at this stage in the history was the
				fact that my home IP was dynamic, and I would have to log onto GoDaddy
				every once in a while to update the DNS of
				<code>emilia-tan.com</code> to point back to my new home IP. Eventually,
				I solved this problem my hosting Emilia on a static IP AWS EC2 instance.
			</p>
			<h3 id="monochrome-3">Monochrome 3</h3>
			<p>
				The next iteration of the Emilia webserver was <code>Monochrome3</code>,
				which actually served a file directory instead of static strings. This
				meant that I actually had to parse the request sent by the browser and
				dynamically set my headers based on which file was requested!
			</p>
			<p>
				The following is a code snippet from the project, called whenever we
				received new data from the socket connection.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-keyword">int</span> error;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BUFLEN = <span class="hljs-number">1024</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> tmp, tmp2, requrl, httpver, reqtype;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; headermap;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> reqfile, param;

<span class="hljs-keyword">if</span> (rfparam-&gt;waitingPOST) <span class="hljs-comment">//we are waiting POST message, and the whole message has arrived now</span>
{
    <span class="hljs-comment">//init parameters</span>
    headermap = rfparam-&gt;headermap;
    reqtype = rfparam-&gt;reqtype;
    requrl = rfparam-&gt;requrl;
    httpver = rfparam-&gt;httpver;

    rfparam-&gt;waitingPOST = <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-comment">//get request info</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> ss;
    ss &lt;&lt; rfparam-&gt;fmess;
    ss &gt;&gt; reqtype &gt;&gt; requrl &gt;&gt; httpver;
    <span class="hljs-built_in">std</span>::getline (ss, tmp);

    <span class="hljs-keyword">while</span> (ss &gt;&gt; tmp)
    {
        <span class="hljs-keyword">if</span> (tmp.back () == <span class="hljs-string">&#x27;:&#x27;</span>)
            tmp.pop_back ();
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> a = <span class="hljs-number">0</span>;a &lt; tmp.size ();a++)
            tmp[a] = <span class="hljs-built_in">tolower</span> (tmp[a]);
        <span class="hljs-keyword">while</span> (ss.peek () == <span class="hljs-string">&#x27; &#x27;</span>)
            ss.get ();
        <span class="hljs-built_in">std</span>::getline (ss, tmp2);
        <span class="hljs-keyword">if</span> (tmp2.back () == <span class="hljs-string">&#x27;\r&#x27;</span>)
            tmp2.pop_back ();
        headermap.insert (<span class="hljs-built_in">make_pair</span> (tmp, tmp2));
    }

    <span class="hljs-comment">//if we have a POST request, don&#x27;t process it just yet - wait until all bytes are here, then execute the command</span>
    <span class="hljs-keyword">if</span> (reqtype == <span class="hljs-string">&quot;POST&quot;</span>)
    {
        <span class="hljs-comment">//save the request</span>
        rfparam-&gt;headermap = headermap;
        rfparam-&gt;reqtype = reqtype;
        rfparam-&gt;requrl = requrl;
        rfparam-&gt;httpver = httpver;

        <span class="hljs-comment">//mark the messageproc function into a special state</span>
        rfparam-&gt;waitingPOST = <span class="hljs-literal">true</span>;
        rfparam-&gt;POSTmessage.clear ();
        rfparam-&gt;POSTlen = Rain::StrToLL (headermap.find (<span class="hljs-string">&quot;content-length&quot;</span>)-&gt;second);

        <span class="hljs-comment">//return, but signal that we are waiting on more messages from client</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}

<span class="hljs-comment">//identify the file pointed to by the URL as well as any parameters</span>
<span class="hljs-keyword">if</span> (requrl == <span class="hljs-string">&quot;/&quot;</span>)
    reqfile = <span class="hljs-string">&quot;index.html&quot;</span>;
<span class="hljs-keyword">else</span>
{
    <span class="hljs-comment">//cut off file at a &#x27;?&#x27; if it exists - anything after that is the parameter</span>
    <span class="hljs-keyword">int</span> quesind = <span class="hljs-number">0</span>;
    requrl = requrl.substr (<span class="hljs-number">1</span>, requrl.size () - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (; quesind &lt; requrl.size (); quesind++)
        <span class="hljs-keyword">if</span> (requrl[quesind] == <span class="hljs-string">&#x27;?&#x27;</span>)
            <span class="hljs-keyword">break</span>;
    reqfile = Rain::DecodeURL (requrl.substr (<span class="hljs-number">0</span>, quesind));
    <span class="hljs-keyword">if</span> (quesind &lt; requrl.size ())
        param = Rain::DecodeURL (requrl.substr (quesind + <span class="hljs-number">1</span>, requrl.size () - quesind - <span class="hljs-number">1</span>));
}

<span class="hljs-comment">//depending on the extension of the file, serve it to the browser in different ways</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> rootdir = <span class="hljs-string">&quot;C:\\Main\\Active\\Documents\\Programming\\Rain\\Developing\\Monochrome0x\\3. HTTPServerFull\\&quot;</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fullpath = rootdir + reqfile, fileext;
reqfile = Rain::GetShortName (fullpath);
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> a = reqfile.length () - <span class="hljs-number">1</span>; a &gt;= <span class="hljs-number">0</span>; a--)
{
    <span class="hljs-keyword">if</span> (reqfile[a] == <span class="hljs-string">&#x27;.&#x27;</span>)
    {
        fileext = reqfile.substr (a + <span class="hljs-number">1</span>, reqfile.length () - a - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> a = <span class="hljs-number">0</span>;a &lt; fileext.length ();a++)
    fileext[a] = <span class="hljs-built_in">tolower</span> (fileext[a]);

<span class="hljs-comment">//try to get the right contenttype</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> contenttype;
contenttype = <span class="hljs-string">&quot;application/octet-stream&quot;</span>;

<span class="hljs-comment">//if exe, run it as a cgi script</span>
<span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;exe&quot;</span>)
{
    <span class="hljs-comment">//set some environment variables for the script</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> tempfile = <span class="hljs-string">&quot;tempfile&quot;</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> envir;
    envir += <span class="hljs-string">&quot;QUERY_STRING=&quot;</span> + param;
    envir.push_back (<span class="hljs-string">&#x27;\0&#x27;</span>);

    <span class="hljs-keyword">auto</span> it = headermap.find (<span class="hljs-string">&quot;referer&quot;</span>);
    <span class="hljs-keyword">if</span> (it != headermap.end ())
        envir += <span class="hljs-string">&quot;HTTP_REFERER=&quot;</span> + it-&gt;second,
        envir.push_back (<span class="hljs-string">&#x27;\0&#x27;</span>);

    it = headermap.find (<span class="hljs-string">&quot;content-length&quot;</span>);
    <span class="hljs-keyword">if</span> (it != headermap.end ())
        envir += <span class="hljs-string">&quot;CONTENT_LENGTH=&quot;</span> + it-&gt;second,
        envir.push_back (<span class="hljs-string">&#x27;\0&#x27;</span>);

    it = headermap.find (<span class="hljs-string">&quot;host&quot;</span>);
    <span class="hljs-keyword">if</span> (it != headermap.end ())
        envir += <span class="hljs-string">&quot;HTTP_HOST=&quot;</span> + it-&gt;second,
        envir.push_back (<span class="hljs-string">&#x27;\0&#x27;</span>);

    envir.push_back (<span class="hljs-string">&#x27;\0&#x27;</span>);

    <span class="hljs-comment">//pipe output of script to a local string</span>
    SECURITY_ATTRIBUTES sa;
    sa.nLength = <span class="hljs-keyword">sizeof</span> (SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;

    HANDLE g_hChildStd_OUT_Rd = <span class="hljs-literal">NULL</span>, g_hChildStd_OUT_Wr = <span class="hljs-literal">NULL</span>,
        g_hChildStd_IN_Rd = <span class="hljs-literal">NULL</span>, g_hChildStd_IN_Wr = <span class="hljs-literal">NULL</span>;
    error = CreatePipe (&amp;g_hChildStd_OUT_Rd, &amp;g_hChildStd_OUT_Wr, &amp;sa, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (!error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    error = SetHandleInformation (g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (!error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    error = CreatePipe (&amp;g_hChildStd_IN_Rd, &amp;g_hChildStd_IN_Wr, &amp;sa, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (!error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    error = SetHandleInformation (g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (!error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;
    ZeroMemory (&amp;sinfo, <span class="hljs-keyword">sizeof</span> (sinfo));
    ZeroMemory (&amp;pinfo, <span class="hljs-keyword">sizeof</span> (pinfo));
    sinfo.cb = <span class="hljs-keyword">sizeof</span> (sinfo);
    sinfo.dwFlags |= STARTF_USESTDHANDLES;
    sinfo.hStdOutput = g_hChildStd_OUT_Wr;
    sinfo.hStdInput = g_hChildStd_IN_Rd;
    error = CreateProcess (
        fullpath.c_str (), 
        <span class="hljs-literal">NULL</span>,
        <span class="hljs-literal">NULL</span>, 
        <span class="hljs-literal">NULL</span>,
        TRUE,
        CREATE_NO_WINDOW,
        <span class="hljs-keyword">reinterpret_cast</span>&lt;LPVOID&gt;(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span> *&gt;(envir.c_str ())),
        fullpath.substr (<span class="hljs-number">0</span>, fullpath.length () - reqfile.length ()).c_str (),
        &amp;sinfo,
        &amp;pinfo);
    <span class="hljs-keyword">if</span> (!error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-comment">//if we are processing a POST request, pipe the request into the in pipe and redirect it to the script</span>
    CHAR chBuf[BUFLEN];
    BOOL bSuccess = FALSE;
    DWORD dwRead, dwWritten;
    <span class="hljs-keyword">if</span> (reqtype == <span class="hljs-string">&quot;POST&quot;</span>)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> a = <span class="hljs-number">0</span>; a &lt; rfparam-&gt;POSTlen;)
        {
            <span class="hljs-keyword">if</span> (a + BUFLEN &gt;= rfparam-&gt;POSTlen)
                bSuccess = WriteFile (g_hChildStd_IN_Wr,
                    rfparam-&gt;POSTmessage.c_str () + a, rfparam-&gt;POSTlen - a, &amp;dwWritten, <span class="hljs-literal">NULL</span>);
            <span class="hljs-keyword">else</span>
                bSuccess = WriteFile (g_hChildStd_IN_Wr,
                    rfparam-&gt;POSTmessage.c_str () + a, BUFLEN, &amp;dwWritten, <span class="hljs-literal">NULL</span>);

            <span class="hljs-keyword">if</span> (!bSuccess) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            a += dwWritten;
        }
    }
    CloseHandle (g_hChildStd_IN_Wr);

    WaitForInputIdle (pinfo.hProcess, <span class="hljs-number">1000</span> * <span class="hljs-number">15</span>); <span class="hljs-comment">//wait a max of 15 secs</span>

    CloseHandle (pinfo.hProcess);
    CloseHandle (pinfo.hThread);
    CloseHandle (g_hChildStd_OUT_Wr);
    CloseHandle (g_hChildStd_IN_Rd);

    <span class="hljs-comment">//send some preliminary header info</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> header = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> (<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>);
    error = Rain::SendText (*rfparam-&gt;sock, header.c_str (), header.length ());
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-comment">//pass the output of the script in the pipe to the client socket, buffered</span>
    <span class="hljs-keyword">for</span> (;;) {
        bSuccess = ReadFile (g_hChildStd_OUT_Rd, chBuf, BUFLEN, &amp;dwRead, <span class="hljs-literal">NULL</span>);
        <span class="hljs-keyword">if</span> (!bSuccess || dwRead == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        
        error = Rain::SendText (*rfparam-&gt;sock, chBuf, dwRead);
        <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    CloseHandle (g_hChildStd_OUT_Rd);
}
<span class="hljs-keyword">else</span>
{
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;pdf&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/pdf&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;aac&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/x-aac&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;avi&quot;</span>)
        contenttype = <span class="hljs-string">&quot;video/x-msvideo&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;bmp&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/bmp&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;torrent&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/x-bittorrent&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;c&quot;</span>)
        contenttype = <span class="hljs-string">&quot;text/x-c&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;csv&quot;</span>)
        contenttype = <span class="hljs-string">&quot;text/csv&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;gif&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/gif&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;html&quot;</span>)
        contenttype = <span class="hljs-string">&quot;text/html&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;ico&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/x-icon&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;java&quot;</span>)
        contenttype = <span class="hljs-string">&quot;text/x-java-source,java&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;jpeg&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/jpeg&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;jpg&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/jpeg&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;docx&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;ppt&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/vnd.ms-powerpoint&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;pub&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/x-mspublisher&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;wma&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/x-ms-wma&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;doc&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/msword&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;mid&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/midi&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;mpeg&quot;</span>)
        contenttype = <span class="hljs-string">&quot;video/mpeg&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;mp4a&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/mp4&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;mp4&quot;</span>)
        contenttype = <span class="hljs-string">&quot;video/mp4&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;png&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/png&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;webm&quot;</span>)
        contenttype = <span class="hljs-string">&quot;video/webm&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;tiff&quot;</span>)
        contenttype = <span class="hljs-string">&quot;image/tiff&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;txt&quot;</span>)
        contenttype = <span class="hljs-string">&quot;text/plain&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;wav&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/x-wav&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;zip&quot;</span>)
        contenttype = <span class="hljs-string">&quot;application/zip&quot;</span>;

    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;mp3&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/mpeg&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;flac&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/flac&quot;</span>;
    <span class="hljs-keyword">if</span> (fileext == <span class="hljs-string">&quot;ogg&quot;</span>)
        contenttype = <span class="hljs-string">&quot;audio/ogg&quot;</span>;

    <span class="hljs-comment">//try to open in browser, and download if not possible</span>
    <span class="hljs-built_in">std</span>::ifstream in;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> headerinfo;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> filelen = <span class="hljs-number">0</span>;
    in.open (fullpath, <span class="hljs-built_in">std</span>::ios::binary);

    <span class="hljs-keyword">if</span> (in.fail ()) <span class="hljs-comment">//404 error</span>
        headerinfo = <span class="hljs-string">&quot;HTTP/1.1 404 Not Found\n\n&quot;</span>;
    <span class="hljs-keyword">else</span>
    {
        in.seekg (<span class="hljs-number">0</span>, in.end);
        filelen = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(in.tellg ());
        in.seekg (<span class="hljs-number">0</span>, in.beg);

        headerinfo = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> (<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>) +
            <span class="hljs-string">&quot;Content-Type: &quot;</span> + contenttype + <span class="hljs-string">&quot;; charset = UTF-8\r\n&quot;</span> +
            <span class="hljs-string">&quot;Content-disposition: inline; filename=&quot;</span> + reqfile + <span class="hljs-string">&quot;\r\n&quot;</span> +
            <span class="hljs-string">&quot;Content-Encoding: UTF-8\r\n&quot;</span> +
            <span class="hljs-string">&quot;Content-Length: &quot;</span> + Rain::LLToStr (filelen) + <span class="hljs-string">&quot;\r\n&quot;</span> +
            <span class="hljs-string">&quot;Server: Rain Server Monochrome03\r\n&quot;</span> +
            <span class="hljs-string">&quot;Accept-Ranges: bytes\r\n&quot;</span> +
            <span class="hljs-string">&quot;Connection: close\r\n&quot;</span> +
            <span class="hljs-string">&quot;\r\n&quot;</span>;
    }
    error = Rain::SendText (*rfparam-&gt;sock, headerinfo.c_str (), headerinfo.length ());
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-comment">//send the file with buffering</span>
    <span class="hljs-keyword">char</span> buffer[BUFLEN];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;a &lt; filelen;a += BUFLEN)
    {
        <span class="hljs-keyword">if</span> (a + BUFLEN &gt; filelen)
        {
            in.read (buffer, filelen - a);
            error = Rain::SendText (*rfparam-&gt;sock, buffer, filelen - a);
        }
        <span class="hljs-keyword">else</span>
        {
            in.read (buffer, BUFLEN);
            error = Rain::SendText (*rfparam-&gt;sock, buffer, BUFLEN);
        }
        <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}

<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//close connection once a full message has been processed</span>
</div></code></pre>
			<p>
				The beginning of the code handles special processing for
				<code>POST requests</code>, which we want to delay until the entire
				<code>POST</code> request arrives. The rest of the code is wrapped in a
				large <code>if</code>. The <code>if</code> segment deals with the case
				where the browser requests a callable script (CGI, which we'll cover
				soon); in which case we want to make the necessary preparations to run
				the script and pipe its output back to the browser. The
				<code>else</code> segment responds to a file request, in which case we
				send back the fildata.
			</p>
			<p>
				<code>Monochrome3</code> was pretty janky. As you can see above, I
				basically ignore all the headers that the browser sends, and simply send
				back the requested file and close the socket. There's a long series of
				<code>if</code>s in the middle of the code which set the
				<code>content-type</code> header of the HTTP response.
			</p>
			<p>
				For all that work, the front-end didn't look that different. It was only
				that this time, I could edit the webpage as an HTML instead of C++. And
				it's much more adaptable. The GIF below showcases
				<code>Monochrome3</code>.
			</p>
			<p>
				<video src="emilia.md-assets/mono-3.webm" autoplay loop muted></video
				><br />
				<em
					>Example use of <code>Monochrome3</code>. The webpage still displays
					<code>Monochrome2</code>, for some reason.</em
				>
			</p>
			<p>
				It's pretty impressive that the server itself worked. Perhaps most
				impressive, however, was the ability to support CGI scripts.
			</p>
			<h3 id="cgi">CGI</h3>
			<p>
				CGI scripts are the beginnings of an actual backend for any website.
				Instead of returning the filedata, the webserver would instead run the
				file as an executable, pipe into it either a <code>POST</code> request
				from <code>stdin</code> or a <code>GET</code> request as part of the
				environment variable block. Then, webservers would typically take the
				output from <code>stdout</code> of the executable and pipe that back to
				the browser as a response.
			</p>
			<p>
				You can see this process of piping in the data and piping out the data
				to the browser in the code for <code>Monochrome3</code> above.
				<code>GET</code> is piped into <code>QUERY_STRING</code>, while
				<code>POST</code> is piped into <code>cin</code>.
			</p>
			<p>
				One of the first things I built was a directory browser called
				<code>FileExplorer</code> through several CGI scripts for uploading,
				deleting, and nagivating, allowing me to modify the files on my server
				back-end remotely! This meant that if I had something I wished to share
				with friends, I could simply upload it to my webserver, and give them a
				link to that!
			</p>
			<p>
				<video
					src="emilia.md-assets/mono-3-cgi.webm"
					autoplay
					loop
					muted
				></video
				><br />
				<em
					>Showcase of the directory browser <code>FileExplorer.exe</code>,
					which allows the browser to see files outside of the server root and
					modify them.</em
				>
			</p>
			<p>
				<code>FileExplorer</code> is as unsafe as unsafe can get. By putting
				<code>FileExplorer</code> on my website, I allow anyone who knows about
				it to change anything with my server machine directly. But, if the
				server is running on my local machine, it's also a good way to access
				the files I want remotely.
			</p>
			<p>
				An interesting detail you may be able to observe is in the URL for the
				<code>FileExplorer</code>, which takes a path script as a hex string
				starting with <code>A</code>, since many path names contain characters
				incompatible with URI accessors in the URL.
			</p>
			<p>
				<video src="emilia.md-assets/emilia-2.webm" autoplay loop muted></video
				><br />
				<em>Another smiling Emilia (also not the webserver).</em>
			</p>
			<h2 id="file-transfer-emiliabackup">File Transfer: EmiliaBackup</h2>
			<p>
				With all of this file transfer work, I decided that it would be cool to
				build a backup service for myself. I named this
				<code>EmiliaBackup</code>. In a way, this paralleled the development of
				<code>Monochrome3</code> by allowing me to familiarize myself with the
				WinAPI calls associated with the filesystem, but not having to deal with
				any HTTP or SMTP protocols. Instead, I build my own grassroots file
				transfer protocol.
			</p>
			<p>
				However, as with any program, bugs are pretty common. More than once did
				I destroy my entire file directory in the process of implementing the
				server. This was because the server would only keep the most up-to-date
				files, but if the checking logic for that was wrong, then sometimes
				files would be deleted by accident. Luckily, I was quite aware that this
				might happen before emarking on <code>EmiliaBackup</code>, and was able
				to restore from my backup multiple times during development. As a
				result, however, development was slow and arduous, setting the mood for
				all deployment routines I would code going forward, with the exception
				of perhaps the modern iteration of Emilia (I hope).
			</p>
			<p>
				You can see the message parser for the server-side of
				<code>EmiliaBackup</code> below. The code is extremely dense with logic
				and also extremely long. Instead of reading it, it's best just to scroll
				past.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ProcFullMess</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *funcparam)</span>
</span>{
    ExtMessParam *emp = <span class="hljs-keyword">reinterpret_cast</span>&lt;ExtMessParam *&gt;(funcparam);

    <span class="hljs-keyword">if</span> (emp-&gt;recvfile) <span class="hljs-comment">//receiving parts of a file, block stream until all are here</span>
    {
        emp-&gt;filebuf += emp-&gt;fullmess;
        emp-&gt;curfilesz += emp-&gt;fullmess.size ();

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(emp-&gt;filebuf.size ()) &gt; emp-&gt;fileinfobuf || emp-&gt;curfilesz == emp-&gt;filelen) <span class="hljs-comment">//output file</span>
        {
            emp-&gt;outfile &lt;&lt; emp-&gt;filebuf;
            emp-&gt;filebuf.clear ();

            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> curpct;
            
            <span class="hljs-keyword">if</span> (emp-&gt;filelen == <span class="hljs-number">0</span>)
                curpct = <span class="hljs-number">100</span>;
            <span class="hljs-keyword">else</span>
                curpct = emp-&gt;curfilesz * <span class="hljs-number">100</span> / emp-&gt;filelen;

            <span class="hljs-keyword">if</span> (curpct != emp-&gt;lastpct)
            {
                emp-&gt;lastpct = curpct;
                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\rFile &quot;</span> &lt;&lt; emp-&gt;thisfile &lt;&lt; <span class="hljs-string">&quot; of &quot;</span> &lt;&lt; emp-&gt;totalfiles &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; emp-&gt;curfilesz &lt;&lt; <span class="hljs-string">&quot; of &quot;</span> &lt;&lt; emp-&gt;filelen &lt;&lt; <span class="hljs-string">&quot; bytes (&quot;</span> &lt;&lt; curpct &lt;&lt; <span class="hljs-string">&quot;%)&quot;</span>;
            }
        }

        <span class="hljs-keyword">if</span> (emp-&gt;curfilesz == emp-&gt;filelen)
        {
            emp-&gt;recvfile = <span class="hljs-literal">false</span>;
            emp-&gt;outfile.close ();

            <span class="hljs-comment">//set new filetime</span>
            <span class="hljs-keyword">wchar_t</span> unicode[MAX_PATH];
            MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, emp-&gt;abspath.c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
            HANDLE hfile = CreateFileW (unicode, GENERIC_WRITE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="hljs-literal">NULL</span>);
            SetFileTime (hfile, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;(emp-&gt;newfiletime));
            CloseHandle (hfile);

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> query;
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> <span class="hljs-title">fmss</span> <span class="hljs-params">(emp-&gt;fullmess, <span class="hljs-built_in">std</span>::ios_base::binary | <span class="hljs-built_in">std</span>::ios_base::in | <span class="hljs-built_in">std</span>::ios_base::out)</span></span>;

        fmss &gt;&gt; query;

        <span class="hljs-keyword">if</span> (query == emp-&gt;exittext)
        {
            Rain::SendText (*emp-&gt;sock, emp-&gt;exittext.c_str (), emp-&gt;exittext.length ());
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (query == <span class="hljs-string">&quot;listdir&quot;</span>)
        {
            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cdirs, cfiles;
            fmss &gt;&gt; cdirs &gt;&gt; cfiles;

            <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">files</span> <span class="hljs-params">(cfiles)</span>, <span class="hljs-title">dirs</span> <span class="hljs-params">(cdirs)</span></span>;
            <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FILETIME&gt; <span class="hljs-title">lastmod</span> <span class="hljs-params">(cfiles)</span></span>;
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> dirpath = Rain::GetExePath () + <span class="hljs-string">&quot;\\&quot;</span> + emp-&gt;addr + <span class="hljs-string">&quot;\\&quot;</span>, tmp;

            <span class="hljs-built_in">std</span>::getline (fmss, tmp);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; cdirs; a++)
                <span class="hljs-built_in">std</span>::getline (fmss, dirs[a]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; cfiles; a++)
            {
                <span class="hljs-built_in">std</span>::getline (fmss, files[a]);
                fmss &gt;&gt; lastmod[a].dwLowDateTime &gt;&gt; lastmod[a].dwHighDateTime;
                <span class="hljs-built_in">std</span>::getline (fmss, tmp);
            }

            <span class="hljs-comment">//make a copy of the files list, sort it, and compare it with a sorted list of files on server. delete files on server which are not on the files list</span>
            <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">filescopy</span> <span class="hljs-params">(files)</span>, serverfiles</span>;
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; needdelete;
            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ptr1, ptr2;

            <span class="hljs-comment">//make sure dirpath exists</span>
            CreateDirToFile (dirpath);

            Rain::GetRelFilePathRec (dirpath, serverfiles, <span class="hljs-string">&quot;*&quot;</span>);
            <span class="hljs-built_in">std</span>::sort (filescopy.begin (), filescopy.end ());
            <span class="hljs-built_in">std</span>::sort (serverfiles.begin (), serverfiles.end ());
            ptr1 = ptr2 = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (; ptr1 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(filescopy.size ()) &amp;&amp; ptr2 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(serverfiles.size ());)
            {
                <span class="hljs-keyword">if</span> (serverfiles[ptr2] &lt; filescopy[ptr1])
                    needdelete.push_back (ptr2++);
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (serverfiles[ptr2] == filescopy[ptr1])
                    ptr1++, ptr2++;
                <span class="hljs-keyword">else</span>
                    ptr1++;
            }

            <span class="hljs-comment">//any files after and at pt2 are also gone</span>
            <span class="hljs-keyword">for</span> (;ptr2 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(serverfiles.size ());ptr2++)
                needdelete.push_back (ptr2);

            <span class="hljs-keyword">wchar_t</span> unicode[MAX_PATH];
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Deleting &quot;</span> &lt;&lt; needdelete.size () &lt;&lt; <span class="hljs-string">&quot; files from &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot; backup...\n&quot;</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>;a &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(needdelete.size ());a++)
            {
                MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, serverfiles[needdelete[a]].c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
                <span class="hljs-comment">//std::cout &lt;&lt; &quot;Deleting &quot; &lt;&lt; unicode &lt;&lt; &quot; from &quot; &lt;&lt; emp-&gt;addr &lt;&lt; &quot;...\n&quot;;</span>
                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Deleting &quot;</span> &lt;&lt; serverfiles[needdelete[a]] &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot;...\n&quot;</span>;
                MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, (dirpath + serverfiles[needdelete[a]]).c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
                DeleteFileW (unicode);
            }

            <span class="hljs-comment">//match directory list as well, and delete extra dirs, which should now be empty</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; serverdirs;
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; needcreate;
            Rain::GetRelDirPathRec (dirpath, serverdirs, <span class="hljs-string">&quot;*&quot;</span>);
            <span class="hljs-built_in">std</span>::sort (dirs.begin (), dirs.end ());
            <span class="hljs-built_in">std</span>::sort (serverdirs.begin (), serverdirs.end ());

            needdelete.clear ();
            ptr1 = ptr2 = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (; ptr1 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(dirs.size ()) &amp;&amp; ptr2 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(serverdirs.size ());)
            {
                <span class="hljs-keyword">if</span> (serverdirs[ptr2] &lt; dirs[ptr1])
                    needdelete.push_back (ptr2++);
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (serverdirs[ptr2] == dirs[ptr1])
                    ptr1++, ptr2++;
                <span class="hljs-keyword">else</span>
                    needcreate.push_back (ptr1++);
            }

            <span class="hljs-keyword">for</span> (; ptr2 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(serverdirs.size ()); ptr2++)
                needdelete.push_back (ptr2);
            <span class="hljs-keyword">for</span> (; ptr1 &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(dirs.size ()); ptr1++)
                needcreate.push_back (ptr1);

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Creating &quot;</span> &lt;&lt; needcreate.size () &lt;&lt; <span class="hljs-string">&quot; directories for &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot; backup...\n&quot;</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(needcreate.size ()); a++)
            {
                MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, dirs[needcreate[a]].c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
                <span class="hljs-comment">//std::cout &lt;&lt; &quot;Creating directory &quot; &lt;&lt; unicode &lt;&lt; &quot; for &quot; &lt;&lt; emp-&gt;addr &lt;&lt; &quot;...\n&quot;;</span>
                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Creating directory &quot;</span> &lt;&lt; dirs[needcreate[a]] &lt;&lt; <span class="hljs-string">&quot; for &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot;...\n&quot;</span>;
                CreateDirToFile ((dirpath + dirs[needcreate[a]]).c_str ());
            }

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Deleting &quot;</span> &lt;&lt; needdelete.size () &lt;&lt; <span class="hljs-string">&quot; directories from &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot; backup...\n&quot;</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(needdelete.size ()); a++)
            {
                MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, serverdirs[needdelete[a]].c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
                <span class="hljs-comment">//std::cout &lt;&lt; &quot;Deleting directory &quot; &lt;&lt; unicode &lt;&lt; &quot; from &quot; &lt;&lt; emp-&gt;addr &lt;&lt; &quot;...\n&quot;;</span>
                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Deleting directory &quot;</span> &lt;&lt; serverdirs[needdelete[a]] &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot;...\n&quot;</span>;
                Rain::RecursiveRmDir (dirpath + serverdirs[needdelete[a]]);
                MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, (dirpath + serverdirs[needdelete[a]]).c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
                RemoveDirectoryW (unicode);
            }

            <span class="hljs-comment">//go to each files and match FILETIME. if not match, add it to array to eventually send back to client, to request that file</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FILETIME&gt; curlastmod;
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; fileslong;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(files.size ()); a++)
                fileslong.push_back (dirpath + files[a]);
            Rain::GetLastModTime (fileslong, curlastmod);

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; needupdate;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(lastmod.size ()); a++)
                <span class="hljs-keyword">if</span> (!SameFileTime (lastmod[a], curlastmod[a]))
                    needupdate.push_back (a);

            <span class="hljs-comment">//send list of requests to client</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> outtext;
            outtext = <span class="hljs-string">&quot;updatefiles &quot;</span> + Rain::LLToStr (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(needupdate.size ()));
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(needupdate.size ()); a++)
                outtext += <span class="hljs-string">&quot; &quot;</span> + Rain::LLToStr (needupdate[a]);
            outtext += emp-&gt;mdelim;

            Rain::SendText (*emp-&gt;sock, outtext.c_str (), outtext.length ());

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; emp-&gt;addr &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; needupdate.size () &lt;&lt; <span class="hljs-string">&quot; file(s) need updating.\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (query == <span class="hljs-string">&quot;file&quot;</span>)
        {
            <span class="hljs-comment">//server has sent us a file, that we requested to be updated. input that file and store it where it goes</span>
            fmss &gt;&gt; emp-&gt;thisfile &gt;&gt; emp-&gt;totalfiles &gt;&gt; emp-&gt;filelen &gt;&gt; emp-&gt;newfiletime.dwLowDateTime &gt;&gt; emp-&gt;newfiletime.dwHighDateTime;

            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> tmp;
            <span class="hljs-built_in">std</span>::getline (fmss, tmp);
            <span class="hljs-built_in">std</span>::getline (fmss, emp-&gt;relpath);
            emp-&gt;thisfile++;

            <span class="hljs-comment">//set the mode of this socket to receiving file, and don&#x27;t switch until we&#x27;ve got all our bytes</span>
            emp-&gt;recvfile = <span class="hljs-literal">true</span>;
            emp-&gt;abspath = Rain::GetExePath () + <span class="hljs-string">&quot;\\&quot;</span> + emp-&gt;addr + <span class="hljs-string">&quot;\\&quot;</span> + emp-&gt;relpath;
            emp-&gt;lastpct = <span class="hljs-number">-1</span>;
            CreateDirToFile (emp-&gt;abspath);
            <span class="hljs-keyword">wchar_t</span> unicode[MAX_PATH];
            MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, emp-&gt;abspath.c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
            emp-&gt;outfile.open (unicode, <span class="hljs-built_in">std</span>::ios_base::binary);
            emp-&gt;curfilesz = <span class="hljs-number">0</span>;

            MultiByteToWideChar (CP_UTF8, <span class="hljs-number">0</span>, emp-&gt;relpath.c_str (), <span class="hljs-number">-1</span>, unicode, MAX_PATH);
            <span class="hljs-comment">//std::cout &lt;&lt; &quot;Receiving: &quot; &lt;&lt; unicode &lt;&lt; &quot;\n&quot;;</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Receiving: &quot;</span> &lt;&lt; emp-&gt;relpath &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Unexpected message.\n&quot;</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
			<p>
				As you're likely almost as tired of scrolling through the code segments
				as I was writing them. Each sync request would reqire a lot of parsing
				from the string coming out of the socket into buffered filedata. It made
				it particularily difficult because the most logical way to implement
				socket managers was with callback routines, but these callbacks would
				often be called in the middle of a full message (if the network was
				being choppy, or just anytime actually), and I would have to implement
				logic to buffer the messages until an entire message was received, which
				required sending a header with each message representing itself or
				otherwise having a clear deliminator as to when a message would end
				(which isn't the best option for filedata obviously), both of which
				would require us to maintain the state of the program across multiple
				message callback calls, which would also entail us to detect when the
				socket has disconnected unexpectedly and reset the internal state and
				rollback any partial file changes we were wrote, and so on...
			</p>
			<p>
				Eventually <code>EmiliaBackup</code> was completed, but I never got
				around to using it. The thing is, there were so many possible things
				that could go wrong with the FTP that it was pretty likely some files
				would get deleted and I would never know about them until a while later.
				It wasn't worth the risk, and it was much easier and faster just to
				backup through a USB 3.0 in a drive.
			</p>
			<h2 id="beyond-isps-smtp--emails">Beyond ISPs: SMTP &amp; Emails</h2>
			<p>
				With all of the recent advancements in my knowledge of network protocols
				and WinAPI sockets, I decided that it would be time to broach the topic
				of emails again early in 2017. Like with the HTTP server, the first step
				was to try to capture an SMTP request. However, this time, I didn't have
				the luxury of a Chrome debugger with me. I was going to have to try to
				setup the monitoring myself.
			</p>
			<p>
				It was trivial to setup listening on port 25, the unencrypted SMTP port,
				having my knowledge of sockets. However, despite sending emails to my
				local IP multiple times from the Gmail web interface, I was never able
				to hear any requests on my listening setup. This, as I eventually found
				out, was the combination of two problems:
			</p>
			<ol>
				<li>
					<p>
						I didn't set an MX record on the DNS for my local IP. In fact, there
						is no way to setup DNS on an IP. Thus, I had to point
						<code>emilia-tan.com</code>'s MX record to my local IP instead, and
						send emails to <code>@emilia-tan.com</code>. Or, I could point the A
						record to my local IP, and point the MX record to <code>@</code>.
					</p>
					<p>
						<img src="emilia.md-assets/godaddy-dns.jpg" alt="" /><br />
						<em><code>emilia-tan.com</code>'s DNS record today.</em>
					</p>
				</li>
				<li>
					<p>
						The ISP was blocking incoming connections to port 25. It turns out
						that most modern ISPs blocking incoming connections to port 25 due
						to the immense amount of spam circulating through email these days.
						I did not want to spend the time to talk to the ISP to convince them
						to open up port 25 for my home internet connection, so I was not
						able to do anything about this problem at this point.
					</p>
					<p>
						Back then, I was not aware of AWS EC2, which would have allowed me
						to set up monitoring there, where incoming connections to port 25
						were not blocked.
					</p>
				</li>
			</ol>
			<p>
				I was not able to solve the second problem until I started at MIT in
				late 2017. MIT's ISP does not block incoming connections on port 25.
				After trying my email listening again, finding on Google to setup my MX
				record, and opening up all ports on my local firewall, success! This was
				almost as exciting as receiving a response from Pixiv. Finally, I had
				Google knocking on my door!
			</p>
			<p>
				<img src="emilia.md-assets/first-smtp.jpg" alt="" /><br />
				<em
					>The first ever SMTP request I ever saw, on a port 25 listener on my
					local machine, sent from Google's SMTP server.</em
				>
			</p>
			<p>
				On the left I have setup code to mimic a simple SMTP server, sending
				back skeleton responses to prompt the remote SMTP server to send more
				data. Instead of dealing with the data, it'll simply print out the data
				to the console, which is on the right. The first few lines after
				<code>Client IP: 209.85.217.194</code> (that's Google's SMTP IP address,
				by the way) are from the SMTP server. The lines after that are of the
				actual email, with headers in the MIME format and the body right below
				that after the boundary.
			</p>
			<p>
				Unfortunately, I no longer have this listening code, but it shouldn't be
				difficult to setup. I won't showcase a GIF for this process.
			</p>
			<p>
				Once I knew how to receive requests, the rest was simple. I would probe
				around with my program and try different responses, learn from Google's
				SMTP server about how to act as an SMTP client, and mimic them to setup
				my own SMTP client to send emails. My initial SMTP server on
				<code>Emilia</code> simply forwarded all the emails to my gmail account,
				MIME headers included.
			</p>
			<h2 id="refining-deployment">Refining Deployment</h2>
			<p>
				At the beginning of my first year at MIT, I also decided that the
				website, along with the new SMTP server, was worth keeping online at all
				times. Instead of running it locally so that it would only be online
				when my computer was active and the application was running, I
				registered my first ever AWS account and setup and EC2 instance and
				hosted it there. Luckily, AWS did not block incoming SMTP connections,
				but they did limit outgoing port 25 connections. It took a while to
				figure out, but I eventually petitioned for the limit to be removed. At
				this point, my webserver was always available, and there were no
				downsides to having it on EC2 instead of my local machine, save for one:
				deployment routines for updates were complicated.
			</p>
			<p>
				<img src="emilia.md-assets/hyperspace.jpg" alt="" /><br />
				<em
					>It was also around this time that I decided that a plaintext website
					wasn't enough, and transitioned to using the Hyperspace template with
					the fileserver. Unfortunately I have not saved the actual website from
					then.</em
				>
			</p>
			<p>
				In the beginning, I synced code changes to my EC2 instance by setting up
				Selective Sync in Dropbox, so that any changes I made on my local
				machine would be almost immediately reflected on my remote EC2 instance.
				The solution was not very good, because sometimes I would modify files
				or logs on my local machine while they would also be updated on the
				instance, and it would get confusing very fast.
			</p>
			<p>
				As a result, I embarked on writing my own deployment routine early in
				2018. The internal mechanics of this were fairly similar to those of
				<code>EmiliaBackup</code>: file transfers, message callbacks, and such.
				However, it quickly grew too complicated. The version which I wrote
				during the summer of 2018 contained so many options that even the
				<code>readme</code> for my repository at that point in time contained a
				long section just to describe the workflows. Here's that section, to
				illustrate how confusing it was:
			</p>
			<blockquote>
				<h3 id="development">Development</h3>
				<p>
					There are four types of files: auxiliary, code, configuration, and
					dynamic.
				</p>
				<ul>
					<li>
						Auxiliary: Files written to but not read by Code, such as logs. This
						can contain sensitive information. Different between all
						environments.
					</li>
					<li>
						Code: Server executables &amp; helpers. Should not include sensitive
						information. Same between all environments.
					</li>
					<li>
						Configuration: Files read by but not written to by Code. Same
						between Staging/Production, but different from Development.
					</li>
					<li>
						Dynamic: Files read/written by Code. Different between all
						environments.
					</li>
				</ul>
				<p>Files are organized in any development root as follows:</p>
				<ul>
					<li>
						Development: Files currently in development. The files under
						development are not guaranteed to be functional at any point in
						time.
						<ul>
							<li>
								Development: Simulation environment under which all dev code
								goes.
								<ul>
									<li>Auxiliary</li>
									<li>
										Code
										<ul>
											<li>EmiliaSite: HTTP/HTTPS webserver.</li>
											<li>EmiliaMail: SMTP client and server.</li>
											<li>EmiliaUpdate: Update server/client.</li>
											<li>
												Common: Shared code between all projects, such as the
												Rain Library
											</li>
										</ul>
									</li>
									<li>Configuration</li>
									<li>Dynamic</li>
								</ul>
							</li>
							<li>Staging: Simulated staging environment.</li>
							<li>Production: Simulated production environment.</li>
							<li>
								Production-Remote: Simulated remote production environment.
							</li>
						</ul>
					</li>
					<li>
						Staging: Intermediary between development and production. Functional
						most of the time.
						<ul>
							<li>Auxiliary</li>
							<li>
								Code: Any code files, in the same structure as in production.
							</li>
							<li>
								Configuration: Any configuration files, same as in production.
							</li>
							<li>Dynamic</li>
						</ul>
					</li>
					<li>
						Production: Files currently in production. guaranteed to be
						functional at all times, as well as identical to production at all
						times if the update script is running.
						<ul>
							<li>Auxiliary</li>
							<li>Code</li>
							<li>Configuration</li>
							<li>Dynamic</li>
						</ul>
					</li>
				</ul>
				<p>Production files running on the server are referred to as Remote.</p>
				<h3 id="flow-terminology">Flow Terminology</h3>
				<p>Downstream-Development-Staging-Production-Upstream</p>
				<h3
					id="updating--deploying-to-aws-eg-emilia-tancom-with-eg-emiliaupdate"
				>
					Updating &amp; Deploying (to AWS e.g.
					<a href="http://emilia-tan.com">emilia-tan.com</a>, with e.g.
					EmiliaUpdate)
				</h3>
				<p>
					Deployment should be non-continuous. The production server will have
					an update server. Development will run an update client which connects
					with the server update script and transfers any changes. This way, we
					can avoid having more private information accesible through github
					while granting full control over deployment.
				</p>
				<p>
					There exists a staging stage between development and production.
					Staging will need to be functional before deployment to production.
				</p>
				<p>
					Files are organized on production exactly as in the /Production
					directory.
				</p>
				<p>
					The update server/client will be referred to as the update script.
					When updating, the update client in <strong>staging</strong> should
					always be used. The update server should be run from
					<strong>production</strong>. Take note that even as the update process
					is underway, production files may change, likely the auxiliary and
					server files. There are several functions the script communication
					should complete:
				</p>
				<ul>
					<li>
						Development to Staging (stage-dev): Updates /Staging with
						/Development as follows:
						<ul>
							<li>Auxiliary: Not modified.</li>
							<li>
								Code: Maintains directory structure with only relevant files
								inside;
								<strong
									>relevant files are determined in a client-side configuration
									file for the update script, under staging</strong
								>, from where the udpate script shall be run. The update script
								may also update itself in this step with the script from
								production.
								<ul>
									<li>
										If the script itself is specified as a relevant staging
										file, then, the script should run another executable, which
										waits until the current executable exits to do the replace
										operation, and then restart the script.
									</li>
								</ul>
							</li>
							<li>Configuration: Not modified.</li>
							<li>Dynamic: Not modified.</li>
						</ul>
					</li>
				</ul>
				<p>
					Before deployment from staging to production, any necessary
					configuration and server file changes should be made in staging.
					Staging will inevitably modify files in production that production
					also modifies. We have an ignore list in the udpate client
					configuraiton which can prevent merge conflicts.
				</p>
				<ul>
					<li>
						Staging to Production (deploy-staging): Before running this command,
						the staging files should be identical to those to be used in
						production. This command will do a few things in the following
						order:
						<ul>
							<li>Shut down remote (prod-stop).</li>
							<li>Download remote files to /Production (prod-download).</li>
							<li>
								Wipe /Production and replace with /Staging,
								<strong
									>ignoring files when wiping specified in the configuration for
									the update client in staging</strong
								>.
								<ul>
									<li>
										Ignored files should be auxiliary, configuration, or server,
										but never code.
									</li>
								</ul>
							</li>
							<li>Upload /Production to remote.</li>
							<li>
								Replace /Staging with /Production, ignoring specified files.
								Might need to use CRH here.
							</li>
						</ul>
					</li>
				</ul>
				<p>There are a few additional functions for ease of use:</p>
				<ul>
					<li>
						Production Download (prod-download): Changes to production files
						(likely auxiliary and server) will be reflected in the development
						environment under /Production.
					</li>
					<li>
						Stage Production (stage-prod): Downloads to /Production, then
						replaces /Staging with /Production, ignoring specified files.
					</li>
					<li>
						Production Stop (prod-stop): Stops production, by executing commands
						specified in the update script configuration.
					</li>
					<li>
						Production Start (prod-start): Starts production, again by executing
						a set of commands specified in configuration.
					</li>
					<li>
						Production Sync Start (sync-stop): Actively update /Production with
						any changes to production. While sync is active, commands other than
						Production Sync Stop cannot be executed.
					</li>
					<li>Production Sync Stop (sync-start): Stops the active sync.</li>
				</ul>
			</blockquote>
			<p>
				Yeah, I had to write this <code>readme</code> basically for myself to
				understand what I needed to do each time I wanted to make even a trivial
				change to the server.
			</p>
			<p>
				Working with the <code>EmiliaUpdate</code> system then was a nightmare
				of trying to copy files around to the right place, updating
				configurations before udpating files, and remembering the correct order
				of commands. Since <code>Emilia</code> also consisted of three disjoint
				servers, the HTML, SMTP, and Update server,
				<code>EmiliaUpdate</code> would also have to manage updating the
				executables for all three servers and restarting them everytime a
				command was run.
			</p>
			<p>The current <code>Emilia</code> is much better about deployment.</p>
			<h3 id="rainlibrary3">RainLibrary3</h3>
			<p>
				<code>EmiliaUpdate</code> used <code>RainLibrary3</code>, pushing the
				library development frontier once again.
			</p>
			<p>
				The penultimate iteration of the Rain library,
				<code>RainLibrary3</code>, is summarized below:
			</p>
			<pre><code><code><div>05/29/18  14:45             1,353 RainAlgorithm.cpp
05/29/18  14:45               481 RainAlgorithm.h
05/29/18  14:45               501 RainError.cpp
05/29/18  14:45               248 RainError.h
05/29/18  14:45                31 RainGdiPlusInclude.cpp
05/29/18  14:45               218 RainGdiPlusInclude.h
05/29/18  14:45                26 RainLibraries.cpp
05/29/18  14:45               597 RainLibraries.h
05/13/18  10:06             1,326 RainLogging.cpp
05/13/18  10:06             2,615 RainLogging.h
05/29/18  14:45                24 RainUtility.cpp
05/29/18  14:45               219 RainUtility.h
05/29/18  14:45             9,482 RainUtilityFile.cpp
05/29/18  14:45             3,102 RainUtilityFile.h
05/29/18  14:45             1,249 RainUtilityGeneral.cpp
05/29/18  14:45               465 RainUtilityGeneral.h
05/13/18  08:06             1,172 RainUtilityHexString.cpp
05/29/18  14:45               776 RainUtilityHexString.h
05/29/18  14:45             4,007 RainUtilityString.cpp
05/29/18  14:45             1,123 RainUtilityString.h
05/29/18  14:45             3,905 RainWindow.cpp
05/29/18  14:45             2,265 RainWindow.h
05/29/18  14:45                27 RainWindowsLAM.cpp
05/29/18  14:45               213 RainWindowsLAM.h
05/29/18  14:45                21 RainWSA2.cpp
05/29/18  14:45               245 RainWSA2.h
05/29/18  14:45                28 RainWSA2Include.cpp
05/29/18  14:45               383 RainWSA2Include.h
05/23/18  08:19             4,080 RainWSA2SendRecv.cpp
05/23/18  08:19             2,746 RainWSA2SendRecv.h
05/29/18  14:45             4,726 RainWSA2Server.cpp
05/29/18  14:45             3,227 RainWSA2Server.h
05/29/18  14:45               592 RainWSA2SMTP.cpp
05/29/18  14:45               254 RainWSA2SMTP.h
05/29/18  14:45             4,253 RainWSA2Utility.cpp
05/23/18  08:19             1,130 RainWSA2Utility.h
</div></code></code></pre>
			<p>
				<code>RainLibrary3</code>'s development also paralleled the continuing
				development of <code>Monochrome3</code>, which at this point, was called
				<code>Emilia</code> already.
				<a href="emilia.md-assets/RainLibrary3">Download</a>.
			</p>
			<h2 id="modern-day-emilia">Modern-Day Emilia</h2>
			<p>
				All of the history brings us to the current iteration of Emilia, the
				5.4.4.1891 server. First, let's take a look at the front-end, which now
				has a
				<a href="https://github.com/GilgameshxZero/emilia-tan-com">real home</a>
				as a repository.
			</p>
			<p>
				<img src="emilia.md-assets/emilia-home.jpg" alt="" /><br />
				<em>The current front-end landing page.</em>
			</p>
			<p>
				I moved away from the Hyperspace theme to a custom theme during the
				summer of 2018, using the same color palette as Hyperspace. However, it
				seemed a bit heavy, so the most recent redesign uses much more faded
				colors, but also a more colorful layout, to display the website.
				Scrollbars are hidden, and there is no page navigation; all the menu
				nagivation is implemented with XHR. The website is very responsive to
				size adjustments, and scrolling and sizing work well on mobile as well
				as opposed to during the summer. Most of the mobile sizing adjustments
				are performed through media queries.
			</p>
			<p>
				The backend of Emilia lives
				<a href="https://github.com/GilgameshxZero/emilia">here</a>. I'll
				explain the manifestation and evolution of each of the components in the
				history of Emilia discussed prior.
			</p>
			<h3 id="rainaeternum">RainAeternum</h3>
			<p>
				The current iteration of the Rain library abandons the numerical
				numbering system. Here's the summary of the files:
			</p>
			<pre><code><code><div>11/27/18  11:06             5,189 algorithm-libraries.cpp
12/03/18  22:55               625 algorithm-libraries.h
12/25/18  10:07               897 condition-variable.cpp
12/25/18  10:07             1,216 condition-variable.h
12/03/18  23:00               223 gdi-plus-include.h
10/09/18  12:07             2,659 network-base.cpp
12/03/18  22:55             1,966 network-base.h
12/20/18  20:40            10,770 network-client-manager.cpp
12/20/18  20:40             5,600 network-client-manager.h
12/19/18  17:59             6,606 network-headed-managers.cpp
12/04/18  14:50             2,110 network-headed-managers.h
12/04/18  10:39               368 network-libraries.h
12/03/18  23:04               953 network-recv-param.h
12/20/18  19:46             2,600 network-recv-thread.cpp
12/20/18  19:46             1,229 network-recv-thread.h
12/20/18  19:39             9,773 network-server-manager.cpp
12/04/18  09:40             5,791 network-server-manager.h
12/20/18  19:52               881 network-smtp.cpp
12/03/18  23:00               401 network-smtp.h
10/09/18  12:10               555 network-socket-manager.h
12/20/18  20:48             3,097 network-utility.cpp
12/20/18  20:47             1,381 network-utility.h
12/03/18  23:01               388 network-wsa-include.h
12/25/18  10:07               941 rain-libraries.h
10/09/18  12:08             3,884 rain-window.cpp
12/03/18  23:01             2,417 rain-window.h
11/28/18  08:11               710 utility-error.cpp
12/20/18  19:52               387 utility-error.h
12/25/18  10:07            12,615 utility-filesystem.cpp
12/25/18  10:07             4,840 utility-filesystem.h
12/20/18  19:46               562 utility-libraries.cpp
11/25/18  15:04               840 utility-libraries.h
12/20/18  20:40             6,808 utility-logging.cpp
12/20/18  20:40             4,263 utility-logging.h
12/20/18  20:02             6,386 utility-string.cpp
12/20/18  19:52             3,215 utility-string.h
12/20/18  19:26               367 utility-time.cpp
12/20/18  19:26               247 utility-time.h
11/25/18  15:05               213 windows-lam-include.h
</div></code></code></pre>
			<p>
				<code>rain-aeternum</code> has unified coding &amp; naming style,
				multithreading-safe functions, and the current functions used in
				<code>Emilia</code>. It is also pretty backwards-compatible with
				<code>RainLibrary3</code>.
				<a href="emilia.md-assets/rain-aeternum.zip">Download</a>.
			</p>
			<p>
				For reference, here's an overview of the classes defined in
				<code>rain-aeternum</code>. We'll talk about some of them later.
			</p>
			<p>
				<img src="emilia.md-assets/rain-classes.jpg" alt="" /><br />
				<em>Overview of <code>rain-aternum</code> classes.</em>
			</p>
			<h3 id="winsock--listening">Winsock &amp; Listening</h3>
			<p>
				Much of the boilerplate code for WSA/winsock is within
				<code>rain-aeternum</code>. Here's a summary of the functions available
				in <code>rain-aeternum</code> for winsock setup.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initWinsock22</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTargetAddr</span><span class="hljs-params">(struct addrinfo **target, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> host, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> port,
                    <span class="hljs-keyword">int</span> family = AF_UNSPEC, <span class="hljs-keyword">int</span> sockType = SOCK_STREAM, <span class="hljs-keyword">int</span> type = IPPROTO_TCP)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getServerAddr</span><span class="hljs-params">(struct addrinfo **server, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> port,
                    <span class="hljs-keyword">int</span> family = AF_INET, <span class="hljs-keyword">int</span> sockType = SOCK_STREAM, <span class="hljs-keyword">int</span> type = IPPROTO_TCP, <span class="hljs-keyword">int</span> flags = AI_PASSIVE)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createSocket</span><span class="hljs-params">(SOCKET &amp;newSocket,
                    <span class="hljs-keyword">int</span> family = AF_UNSPEC, <span class="hljs-keyword">int</span> sockType = SOCK_STREAM, <span class="hljs-keyword">int</span> type = IPPROTO_TCP)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectTarget</span><span class="hljs-params">(SOCKET &amp;cSocket, struct addrinfo **target)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bindListenSocket</span><span class="hljs-params">(struct addrinfo **addr, SOCKET &amp;lSocket)</span></span>;
<span class="hljs-function">SOCKET <span class="hljs-title">acceptClientSocket</span><span class="hljs-params">(SOCKET &amp;lSocket)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeAddrInfo</span><span class="hljs-params">(struct addrinfo **addr)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shutdownSocketSend</span><span class="hljs-params">(SOCKET &amp;cSocket)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sendRawMessage</span><span class="hljs-params">(SOCKET &amp;sock, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cstrtext, <span class="hljs-keyword">int</span> len)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sendRawMessage</span><span class="hljs-params">(SOCKET &amp;sock, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strText)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sendRawMessage</span><span class="hljs-params">(SOCKET &amp;sock, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> *strText)</span></span>;
</div></code></pre>
			<p>
				It's pretty rare that I touch any WSA/winsock functions these days
				beyond this abstraction layer.
			</p>
			<h3 id="multithreading-accepting-multiple-connections">
				Multithreading: Accepting Multiple Connections
			</h3>
			<p>Any webserver will need to multithread to deal with many clients.</p>
			<ul>
				<li>
					For clients: one thread will block on <code>recv</code>. On connect,
					message, and disconnect, the <code>recvThread</code> will call
					handlers. Handlers can spawn additional threads to
					<code>send</code> in the socket outside of the callback model.
				</li>
				<li>
					For servers: one thread will block on <code>listen</code>. For any new
					sockets spawned from <code>listen</code>, we'll spawn a
					<code>recvThread</code> for that socket, which has its own handlers
					and variables.
				</li>
			</ul>
			<p>
				The <code>RecvHandlerParam</code> contains crucial information that the
				<code>recvThread</code> needs.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecvHandlerParam</span> {</span>
    <span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//event handler function type</span>
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*EventHandler)</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span></span>;

    RecvHandlerParam();
    RecvHandlerParam(SOCKET *socket, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> *message, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> bufLen, <span class="hljs-keyword">void</span> *funcParam, EventHandler onConnect, EventHandler onMessage, EventHandler onDisconnect);

    <span class="hljs-comment">//socket between server and client</span>
    SOCKET *socket;

    <span class="hljs-comment">//place where message is stored for use by any EventHandler</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> *message;

    <span class="hljs-comment">//length of buffer for recv</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> bufLen;

    <span class="hljs-comment">//parameter to be passed to EventHandler</span>
    <span class="hljs-keyword">void</span> *funcParam;

    <span class="hljs-comment">//called whenever recv returns something to the buffer</span>
    <span class="hljs-comment">//return nonzero to terminate recv loop</span>
    EventHandler onMessage;

    <span class="hljs-comment">//called when RecvThread is about to start or end</span>
    <span class="hljs-comment">//return nonzero to terminate recv immediately</span>
    EventHandler onConnect;
    EventHandler onDisconnect;
};
</div></code></pre>
			<p>
				<code>ClientSocketManager</code> and
				<code>ServerManager</code> implement the abstraction described above,
				with many more capabilities to manage inconsistent connections and
				concurrency. <code>ServerManager</code> spawns
				<code>ServerSocketManagers</code> as described above, each of which has
				its own <code>recvThread</code> and set of parameters. Both
				<code>ClientSocketManager</code> and <code>ServerManager</code> have
				<code>SocketManager</code> as a superclass.
				<code>SocketManager</code> declares pure virtual functions useful for
				logging and message sending.
			</p>
			<p>
				The <code>HeadedClientSocketManager</code> and
				<code>HeadedServerManager</code> extend and build an abstraction layer
				atop <code>ClientSocketManager</code> and <code>ServerManager</code>.
				<code>Headed</code> managers only call their message callbacks on
				<code>recv</code> when they've received a full message. Each message is
				sent with either a 2-byte or a 6-byte header containing the length of
				the message, depending on whether the length is longer than 65536 bytes
				(storable within 2 bytes) or not.
			</p>
			<h3 id="build--versioning">Build &amp; Versioning</h3>
			<p>
				The main development routine of <code>Emilia</code> is through Visual
				Studio. Within Visual Studio, on every build, a pre-build event is run
				containing the same batch file as in the previous versioning section.
				The batch file increments the build number in this header file
				<code>build.h</code>.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRINGIZE2(s) #s</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STRINGIZE(s) STRINGIZE2(s)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_MAJOR            5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_MINOR            4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_REVISION         4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VERSION_BUILD            1891</span>
</div></code></pre>
			<p>
				Once again, the resource file <code>rc.rc</code> includes this
				<code>build.h</code> file and uses it to version the application EXE.
			</p>
			<pre><code><code><div>#include &quot;build.h&quot;

1 ICON &quot;icon.ico&quot;

1 VERSIONINFO
    FILEVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_REVISION,VERSION_BUILD
BEGIN
    BLOCK &quot;StringFileInfo&quot;
    BEGIN
        BLOCK &quot;040904E4&quot;
        BEGIN
            VALUE &quot;FileDescription&quot;, &quot;Emilia&quot;
            VALUE &quot;FileVersion&quot;, STRINGIZE(VERSION_MAJOR) &quot;.&quot; STRINGIZE(VERSION_MINOR) &quot;.&quot; STRINGIZE(VERSION_REVISION) &quot;.&quot; STRINGIZE(VERSION_BUILD)
            VALUE &quot;ProductName&quot;, &quot;Emilia&quot;
            VALUE &quot;ProductVersion&quot;, STRINGIZE(VERSION_MAJOR) &quot;.&quot; STRINGIZE(VERSION_MINOR) &quot;.&quot; STRINGIZE(VERSION_REVISION) &quot;.&quot; STRINGIZE(VERSION_BUILD)
        END
    END
    BLOCK &quot;VarFileInfo&quot;
    BEGIN
        VALUE &quot;Translation&quot;, 0x409, 1252
    END
END
</div></code></code></pre>
			<p>
				In some cases, <code>Emilia</code> may need to access the version of the
				current executable. One way to do this is to include
				<code>build.h</code> in the relevant <code>.cpp</code> file. However,
				this means that we have to rebuild <code>Emilia</code> and all files
				which include <code>build.h</code> either directly or indirectly every
				time <code>build.h</code> is modified, which is on every build. Instead,
				<code>build.h</code> is excluded from the build targets, and all code
				which needs to access to version number will do so by including
				<code>build-helper.h</code>, which declares the function defined below.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getVersionStr</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> major = <span class="hljs-number">0</span>, minor, revision, build;

    <span class="hljs-comment">//if not called before, read the build file</span>
    <span class="hljs-keyword">if</span> (major == <span class="hljs-number">0</span>) {
        <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;..\\rc\\build.h&quot;</span>)</span></span>;
        <span class="hljs-keyword">while</span> (in) {
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> token;
            in &gt;&gt; token;
            <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&quot;VERSION_MAJOR&quot;</span>) {
                in &gt;&gt; token;
                major = Rain::strToT&lt;<span class="hljs-keyword">int</span>&gt;(token);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&quot;VERSION_MINOR&quot;</span>) {
                in &gt;&gt; token;
                minor = Rain::strToT&lt;<span class="hljs-keyword">int</span>&gt;(token);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token == <span class="hljs-string">&quot;VERSION_REVISION&quot;</span>) {
                in &gt;&gt; token;
                revision = Rain::strToT&lt;<span class="hljs-keyword">int</span>&gt;(token);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token == <span class="hljs-string">&quot;VERSION_BUILD&quot;</span>) {
                in &gt;&gt; token;
                build = Rain::strToT&lt;<span class="hljs-keyword">int</span>&gt;(token);
            }
        }
        in.close();
    }

    <span class="hljs-keyword">return</span> Rain::tToStr(major) + <span class="hljs-string">&quot;.&quot;</span> + Rain::tToStr(minor) + <span class="hljs-string">&quot;.&quot;</span> + Rain::tToStr(revision) + <span class="hljs-string">&quot;.&quot;</span> + Rain::tToStr(build);
}
</div></code></pre>
			<p>
				Reading <code>build.h</code> directly is the only way we can avoid
				rebuilding <code>Emilia</code> on a changing <code>build.h</code> while
				still making versioning accessible within <code>Emilia</code>. This
				saves developer hours waiting on compilation.
			</p>
			<h3 id="http-server">HTTP Server</h3>
			<p>
				The HTTP server on <code>Emilia</code> is set up in almost exactly the
				same way as in Monochrome3. There are many more configuration options,
				and we've now disabled accessing files outside of the root directory.
				<code>onMessage</code> waits for a full HTTP request to come in before
				parsing it, and <code>processRequest</code> delegates to either a 404,
				the file, or a CGI script depending on whether or not the file exists
				and whether the file is specified as a CGI script in the configuration.
				The configuration also specifies <code>Content-Type</code> headers.
				Moreover, bytes transferred to and from the server are done so buffered,
				so that larger files are also not a problem for <code>Emilia</code>.
			</p>
			<p>
				One recent addition to <code>Emilia</code> is implementing every
				<code>ServerSocketManager</code> with an additional
				<code>requestThread</code> beyond the <code>recvThread</code>, which is
				responsible for processing all the requests, and locked until
				<code>onMessage</code> unlocks it. This allows for
				<code>onDisconnect</code> handlers to be called while requests are being
				processed, which would terminate the <code>requestThread</code> instead
				of having it run while the connection is already closed.
			</p>
			<h3 id="cgi-scripts">CGI Scripts</h3>
			<p>
				While the main portion of <code>Emilia</code> is developed in Visual
				Studio, the CGI scripts are not VS projects themselves, but standalone
				C++ files. I compile them manually using the following batch script
				during development, and the resulting EXE files are copied onto the HTTP
				server root directory.
			</p>
			<p>
				Manual compilation avoids the need for projects, which increases the
				development time of each script.
			</p>
			<pre><code class="language-bat"><div><span class="hljs-built_in">set</span> filename=%<span class="hljs-number">1</span>

<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">defined</span> DevEnvDir (
    <span class="hljs-keyword">call</span> &quot;C:\Program Files (x86)\Microsoft Visual Studio\<span class="hljs-number">2017</span>\Community\VC\Auxiliary\Build\vcvarsall.bat&quot; x64
)

<span class="hljs-keyword">call</span> pre-build-event.bat
<span class="hljs-built_in">cd</span> ..\src\scripts

<span class="hljs-keyword">if</span> &quot;%~<span class="hljs-number">2</span>&quot;==&quot;aeternum&quot; (
    <span class="hljs-keyword">call</span> cl ^
    /EHsc ^
    /Fo&quot;..\..\obj\scripts\\&quot; ^
    /Fe&quot;..\..\bin\scripts\<span class="hljs-variable">%filename%</span>.exe&quot; ^
    /Fd&quot;..\..\obj\scripts\\&quot; ^
    /O2 ^
    /Ot ^
    /Ox ^
    /MT ^
    /MP ^
    /incremental ^
    ..\rain-aeternum\*.cpp ^
    &quot;<span class="hljs-variable">%filename%</span>.cpp&quot;
) <span class="hljs-keyword">ELSE</span> (
    <span class="hljs-keyword">call</span> cl ^
    /EHsc ^
    /Fo&quot;..\..\obj\scripts\\&quot; ^
    /Fe&quot;..\..\bin\scripts\<span class="hljs-variable">%filename%</span>.exe&quot; ^
    /Fd&quot;..\..\obj\scripts\\&quot; ^
    /O2 ^
    /Ot ^
    /Ox ^
    /MT ^
    /MP ^
    /incremental ^
    &quot;<span class="hljs-variable">%filename%</span>.cpp&quot;
)

<span class="hljs-built_in">cd</span> ..\..\build
<span class="hljs-keyword">call</span> post-build-event.bat
</div></code></pre>
			<p>
				Below is the CGI script which manages the subscribers to my mailing
				list.
			</p>
			<pre><code class="language-c++"><div><span class="hljs-comment">/*
Emilia-tan Script

This script modifies the subscriber list for the mailing list.
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;../rain-aeternum/rain-libraries.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> DATA_FILE = <span class="hljs-string">&quot;..\\..\\data\\mlist-subs.ini&quot;</span>;

    _setmode(_fileno(<span class="hljs-built_in">stdout</span>), _O_BINARY);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> response;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; query = Rain::getQueryToMap(<span class="hljs-built_in">std</span>::getenv(<span class="hljs-string">&quot;QUERY_STRING&quot;</span>));

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> action = query[<span class="hljs-string">&quot;action&quot;</span>],
        email = query[<span class="hljs-string">&quot;email&quot;</span>];
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; subs = Rain::readMultilineFile(DATA_FILE);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; subSet;
    subSet.insert(subs.begin(), subs.end());
    <span class="hljs-keyword">if</span> (action == <span class="hljs-string">&quot;remove&quot;</span>) {
        <span class="hljs-keyword">if</span> (subSet.find(email) == subSet.end()) {
            response = <span class="hljs-string">&quot;Already unsubscribed&quot;</span>;
        } <span class="hljs-keyword">else</span> {
            response = <span class="hljs-string">&quot;Unsubscribed&quot;</span>;
        }
        subSet.erase(email);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action == <span class="hljs-string">&quot;add&quot;</span>) {
        <span class="hljs-keyword">if</span> (subSet.find(email) == subSet.end()) {
            response = <span class="hljs-string">&quot;Subscribed&quot;</span>;
        } <span class="hljs-keyword">else</span> {
            response = <span class="hljs-string">&quot;Already subscribed&quot;</span>;
        }
        subSet.insert(email);
    }
    Rain::printToFile(DATA_FILE, <span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = subSet.begin(); it != subSet.end(); it++) {
        Rain::printToFile(DATA_FILE, *it + Rain::LF, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span> &lt;&lt; Rain::CRLF
        &lt;&lt; <span class="hljs-string">&quot;content-type:text/html&quot;</span> &lt;&lt; Rain::CRLF
        &lt;&lt; Rain::CRLF
        &lt;&lt; response;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
			<p>
				CGI scripts are fairly lightweight, even though they're implemented in
				C++.
			</p>
			<p>
				<video
					src="emilia.md-assets/cgi-emails.webm"
					autoplay
					loop
					muted
				></video
				><br />
				<em
					>Showcasing the calling and response of the CGI script on click of the
					<code>Submit</code> button on the homepage.</em
				>
			</p>
			<h3 id="configuration">Configuration</h3>
			<p>
				Many of the magic numbers spread throughout
				<code>Monochrome3</code> have been moved to a configuration file.
			</p>
			<pre><code><code><div>config-path:            ..\config\

log-path:               ..\logs\
log-error:              errors.log
log-memory:             memory-leaks.log
log-log:                log.log

data-path:              ..\data\

emilia-auth-pass:       emilia-password

http-cgi-scripts:       http-cgi.ini
http-custom-headers:	http-headers.ini
http-content-type:      http-content-type.ini
http-404:               http-404.html
http-server-root:       ..\root\
http-default-ctype:     application/octet-stream
http-default-index:     index.html
http-transfer-buffer:	65536
http-cgi-timeout:       0

smtp-users:             mail-users.ini
smtp-domain:	        emilia-tan.com
smtp-transfer-buffer:	65536
smtp-connect-timeout:	5000

update-server-port:     50368
update-tmp-ext:         .tmp
update-transfer-buffer:	65500
update-server-exit-to:	10000
update-exclusive-files:	update-exclusives.ini
update-ignore-files:	update-ignores.ini
update-exc-ignore:      update-exc-ignores.ini
update-exclusive-dir:	exclusive\
update-root:            ..\
update-script:          bin\update-script.bat
</div></code></code></pre>
			<p>
				There exists a local version of the config file, but also a production
				version, which contains a different <code>emilia-auth-pass</code>, which
				is used by the update client to connect to the built-in update server.
				We'll talk more about this later.
			</p>
			<h3 id="logging">Logging</h3>
			<p>
				As part of the debugging process, log files have been sometimes quite
				helpful in finding out the problem with a crash or an undelivered email.
				Logs are synced between local and production within the deployment
				routine. Below is an sample of the log in regards to the HTTP server.
			</p>
			<pre><code><code><div>12/22/18.06:38:59-0000 168
HTTP Client disconnected from 73.228.114.27. Total: 8.
HTTP Client disconnected from 73.228.114.27. Total: 7.
HTTP Client disconnected from 73.228.114.27. Total: 6.


12/22/18.06:39:50-0000 499
GET /tech-blog/assets/mit-confessions-bot/fetch.zip HTTP/1.1
Host: emilia-tan.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
DNT: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: http://emilia-tan.com/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9,ja;q=0.8,zh-CN;q=0.7,zh;q=0.6



12/22/18.06:39:50-0000 68
73.228.114.27: GET /tech-blog/assets/mit-confessions-bot/fetch.zip


12/22/18.06:40:04-0000 54
HTTP Client connected from 194.147.32.109. Total: 7.
</div></code></code></pre>
			<p>
				An abbreviated version of the log is output to the console. Below is a
				GIF demonstrating this in action.
			</p>
			<p>
				<video
					src="emilia.md-assets/console-output.webm"
					autoplay
					loop
					muted
				></video>
			</p>
			<p>
				The corresponding class in <code>rain-aeternum</code> is
				<code>LogStream</code>, which also has options to capture logs from
				<code>cout</code>, <code>cin</code>, <code>cerr</code>, and sockets.
			</p>
			<h3 id="emails--smtp">Emails &amp; SMTP</h3>
			<p>
				The SMTP server on <code>Emilia</code> is slightly more complicated than
				after the initial discovery. The internal state of the request during
				the handshake is managed by a function pointer to the callback to handle
				an incoming request. Otherwise, responses to the remote server are
				generally pretty standard and not very customizable. Since
				<code>Emilia</code> is also responsible for forwarding emails, it also
				contains an implementation of an SMTP client, which is not shown below.
			</p>
			<p>
				I won't provide the code here, but if you are curious, feel free to
				check out the repository.
			</p>
			<p>
				This SMTP client is open to the world. That is, you can use the SMTP
				client on <code>Emilia</code> to basically send whatever email you wish,
				even from people to whose email account you do not have access. I've
				built a web-accessible endpoint with a CGI script and some JS which you
				can access at the home page of <code>Emilia</code>'s front-end.
			</p>
			<h3 id="deployment">Deployment</h3>
			<p>
				The final component to <code>Emilia</code> is the deployment routine.
				Instead of having three separate processes running as with earlier
				iterations and Monochrome3, the HTTP, SMTP, and update servers are all
				combined into one process.
			</p>
			<p>The specific commands are described in the readme, and below.</p>
			<blockquote>
				<h2 id="deployment-overview">Deployment Overview</h2>
				<p>
					There are two types of files in this project: <code>shared</code> and
					<code>exclusive</code>.
				</p>
				<ul>
					<li>
						<code>shared</code>: The same file should exist between all
						distributions of this project.
					</li>
					<li>
						<code>exclusive</code>: A separate version of this file should exist
						on each distribution of the project.
					</li>
				</ul>
				<p>
					File types are specified in the config file of a server.
					<code>shared</code> files are those not marked <code>exclusive</code>.
				</p>
				<h2 id="commands">Commands</h2>
				<table>
					<thead>
						<tr>
							<th>Command</th>
							<th>Action</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>exit</td>
							<td>Exits the process.</td>
						</tr>
						<tr>
							<td>help</td>
							<td>Lists all available commands.</td>
						</tr>
						<tr>
							<td>connect</td>
							<td>
								Connect to remote update server. Not available if already
								connected to a remote server.
							</td>
						</tr>
						<tr>
							<td>disconnect</td>
							<td>Disconnect from a remote connection.</td>
						</tr>
						<tr>
							<td>push</td>
							<td>
								Overwrite the remote <code>shared</code> files with the local
								ones.
							</td>
						</tr>
						<tr>
							<td>push-exclusive</td>
							<td>
								Overwrite the remote <code>exclusive</code> files with the local
								ones specific to the domain.
							</td>
						</tr>
						<tr>
							<td>pull</td>
							<td>
								Overwrite local <code>exclusive</code> files specific to the
								domain with remote <code>exclusive</code> files.
							</td>
						</tr>
						<tr>
							<td>sync</td>
							<td>
								Runs <code>push</code>, then <code>push-exclusive</code>, then
								<code>pull</code> in series.
							</td>
						</tr>
						<tr>
							<td>start</td>
							<td>
								Starts the HTTP and SMTP servers, or the remote HTTP and SMTP
								servers if connected.
							</td>
						</tr>
						<tr>
							<td>stop</td>
							<td>
								Stops the HTTP and SMTP servers, or the remote HTTP and SMTP
								servers if connected.
							</td>
						</tr>
						<tr>
							<td>restart</td>
							<td>
								Restarts the HTTP and SMTP servers, or the remote HTTP and SMTP
								servers if connected.
							</td>
						</tr>
						<tr>
							<td>restart-all</td>
							<td>
								Restarts the application, or the remote application if
								connected.
							</td>
						</tr>
					</tbody>
				</table>
			</blockquote>
			<p>
				The specific update server/clients transfer files in much the same way
				as <code>EmiliaUpdate</code>, though with the
				<code>Headed</code> servers described above for header and message
				parsing. Files are diffed using their last write time, and only new
				files are updated. There are minimal configuration sets associated with
				the update routine to ignore or include files and not cause as much
				confusion as with the<code> 3.1.3</code> <code>Emilia</code>.
			</p>
			<p>
				In the event that a file locked by the server process is undergoing
				updating, <code>Emilia</code> saves the updated file to a
				<code>.tmp</code> extension which is the copied over to the original
				file when the original file is unlocked. To unlock the original file, we
				wait until the entire update process is complete and restart the process
				once all the pending copy operations are complete. This restart and copy
				process is accomplished through a batch file
				<code>update-script.bat</code>, which <code>Emilia</code> calls for each
				file which is locked and needs to be updated.
			</p>
			<h4 id="update-scriptbat">update-script.bat</h4>
			<pre><code class="language-bat"><div>@<span class="hljs-built_in">echo</span> off
<span class="hljs-built_in">set</span> server=%<span class="hljs-number">1</span>
<span class="hljs-built_in">set</span> src=%<span class="hljs-number">2</span>
<span class="hljs-keyword">if</span> &quot;%~<span class="hljs-number">3</span>&quot;==&quot;&quot; (
    <span class="hljs-built_in">set</span> dest=<span class="hljs-variable">%server%</span>
    <span class="hljs-built_in">echo</span> no destination found; replacing <span class="hljs-variable">%server%</span> instead
) <span class="hljs-keyword">else</span> (
    <span class="hljs-built_in">set</span> dest=%<span class="hljs-number">3</span>
)
:file_locked
    <span class="hljs-number">2</span>&gt;<span class="hljs-built_in">nul</span> (
        &gt;&gt;<span class="hljs-variable">%dest%</span> <span class="hljs-built_in">echo</span> off
    ) &amp;&amp; (
        <span class="hljs-built_in">echo</span> <span class="hljs-variable">%dest%</span> writable now! writing to file
    ) || (
        <span class="hljs-built_in">echo</span> <span class="hljs-variable">%dest%</span> <span class="hljs-keyword">not</span> writable; waiting...
        timeout <span class="hljs-number">1</span>
        <span class="hljs-keyword">goto</span> :file_locked
    )
<span class="hljs-built_in">move</span> /y <span class="hljs-variable">%src%</span> <span class="hljs-variable">%dest%</span>
<span class="hljs-comment">rem allow time for concurrent update scripts to finish</span>
timeout <span class="hljs-number">1</span>
<span class="hljs-built_in">start</span> &quot;Emilia&quot; <span class="hljs-variable">%server%</span> &quot;update-restart&quot;
</div></code></pre>
			<p>I actually wrote this one myself! Batch is hard...</p>
			<p>
				Here's how a typical deployment might look like, with the
				<code>sync</code> command.
			</p>
			<p>
				<video src="emilia.md-assets/sync.webm" autoplay loop muted></video
				><br />
				<em
					>Running the <code>sync</code> command. The remote server does not
					need to restart since we don't write to any locked files.</em
				>
			</p>
			<h2 id="final-thoughts">Final Thoughts</h2>
			<p>
				<video src="emilia.md-assets/emilia-3.webm" autoplay loop muted></video
				><br />
				<em>Yet another smiling Emilia (again, not the webserver).</em>
			</p>
			<p>
				It's taken a very long time to learn everything I needed to know to make
				<code>Emilia</code> what it is today over the course of an entire eight
				years through experimentation. I'm sure I could have learned a fraction
				of what I know now by reading up on the protocols, but frankly, that
				would have been much less fun. Looking back, I treasure all the
				breakthroughs and discoveries I made while implementing
				<code>Emilia</code>. Now, with the server how it is, updates to it are
				generally quality-of-life updates and not too critical. The most
				exciting thing going forward would likely be the flexibility provided to
				me through the CGI scripts and exploiting that to make some cool web
				services. I'm wrestling with ideas of a music radio and a database
				service right now.
			</p>
			<p>
				<code>Emilia</code> (and previously, <code>Monochrome3</code> and
				<code>PixivBot</code>) have always been solitary projects. I doubt they
				will ever change from that. I find a certain joy in sitting down and
				forgetting everything and coding on a project which has near-infinite
				potential but will also never be used by many more than just me.
				Sometimes, it may be frustrating, but most of the times its calming
				knowing that everything I need to know I can gather by myself and
				without anyone's help. I doubt <code>Emilia</code> will ever get more
				low-level than it is right now, but I would gladly welcome more
				fundamental challenges again.
			</p>
			<p>
				In the end, this post is more for myself to remember the miniscule roots
				I came from to arrive at <code>Emilia</code>. Looking back, it's really
				been incredible that I've been able to do so much alone. I only hope
				that when working with others, I can accomplish even greater things.
			</p>
		</template>
	</body>
</html>
